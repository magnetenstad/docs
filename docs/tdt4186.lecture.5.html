<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Katex -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
  <!-- GitHub Markdown Styles -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>
  
  <title>tdt4186.lecture.5.md</title>
  <link rel="icon" type="image/x-icon" href="null">
  
<!-- Custom Styles -->
<link rel="stylesheet" href="styles.css">


</head>
<body>
<article class="markdown-body">

<p>↩️ <a href="./index.html">vault/public</a></p>
<h2>Lecture 5: Threads</h2>
<p><a href="tdt4186.lecture.4.html">Previous lecture</a>
<a href="tdt4186.lecture.6.html">Next lecture</a></p>
<p>&lt;iframe
width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/jh2UN8KEy9s&quot;
title=&quot;YouTube video player&quot;
frameborder=&quot;0&quot;
allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
allowfullscreen</p>
<blockquote>
<p>&lt;/iframe&gt;</p>
</blockquote>
<h3>Exam</h3>
<p>Threads as a lightweight abstraction and process alternative</p>
<p><strong>Important questions:</strong></p>
<ul>
<li>What is the overhead of Unix processes and their creation?</li>
<li>What are the differences between address spaces for processes and threads?</li>
<li>What are the thread models in Unix and Windows?</li>
<li>What are fibers (user-level threads)?
<ul>
<li>Can you discuss pros and cons of threads vs. fibers?</li>
</ul>
</li>
<li>Cooperative multithreading
<ul>
<li>Can you describe the ideas behind Duff’s device and protothreads? (you don’t have to know the details of their implementations)</li>
</ul>
</li>
</ul>
<h3>Lightweight processes - threads</h3>
<ul>
<li>With processes, there is a 1:1 relation between control flow and address space
<ul>
<li>Even for forked processes due to copy-on-write</li>
</ul>
</li>
<li>Closely cooperating threads can share an address space
<ul>
<li>code + data + bss + heap, but not the stack!</li>
<li>Why not the stack?
<ul>
<li>Each thread has an independent flow of control</li>
<li>Accordingly, it required an independent call hierarchy, local variables etc.</li>
</ul>
</li>
</ul>
</li>
<li>Advantages of threads:
<ul>
<li>Complex operations can be delegated to a lightweight helper thread</li>
<li>The parent thread can already wait for input while the helper thread is running -&gt; reduced latency (response time)</li>
</ul>
</li>
</ul>
<h3>Threads example</h3>
<ul>
<li>Typical use case for threads: web server</li>
<li>Programs consisting of independent control flows can immediately benefit from multiprocessor systems</li>
<li>Fast context switch: no need to copy the address space
<ul>
<li>only switch the stack pointer - one CPU register</li>
</ul>
</li>
<li>Disadvantage of threads
<ul>
<li>Difficult to error-prone to program</li>
<li>Acces to shared data of threads requires coordinations</li>
<li>OS still has to schedule threads -&gt; overhead</li>
</ul>
</li>
</ul>
<h3>Threads in Windows</h3>
<p><img src="assets/tdt4186.lecture.5.threads_in_windows.png" alt=""></p>
<h3>Threads in Windows (2)</h3>
<ul>
<li>Process: provides environment and address space for threads
<ul>
<li>But has no execution context itself!</li>
</ul>
</li>
<li>A Win32 process always contains at least one thread</li>
<li>Thread: unit executing code
<ul>
<li>Every thread has its own stack and CPU register set (escpecially the program counter)</li>
<li>The scheduler allocated compute time to the threads</li>
</ul>
</li>
<li>All threads are kernel level threads
<ul>
<li>User level threads (fibers) are possible, but unusual</li>
</ul>
</li>
<li>Stretegy: Keep the number of threads low
<ul>
<li>Use overlapping (asynchronous) I/O</li>
</ul>
</li>
</ul>
<h3>Threads in Linux</h3>
<ul>
<li>Linux implements POSIX threads using the pthreads library</li>
<li>pthreads on Linux use a Linux-specific system call:</li>
</ul>
<p>Linux system call: <code>int __clone(<span class="hljs-keyword">in</span> <span class="hljs-comment">(*fn)(void*)</span>, void *stack, int <span class="hljs-keyword">flags</span>, void *arg)</code>
Universal function, parameterized using the flags parameter:</p>
<table>
<thead>
<tr>
<th>_</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class="hljs-attribute">CLONE_VM</span></code></td>
<td>use a common address space</td>
</tr>
<tr>
<td><code><span class="hljs-attribute">CLONE_FS</span></code></td>
<td>share information about the file system</td>
</tr>
<tr>
<td><code><span class="hljs-attribute">CLONE_FILES</span></code></td>
<td>share file descriptors (open files)</td>
</tr>
<tr>
<td><code><span class="hljs-attribute">CLONE_SIGHAND</span></code></td>
<td>share the signal handler table</td>
</tr>
</tbody>
</table>
<ul>
<li>In Linux, all threads and processes are internally managed as tasks
<ul>
<li>The scheduler does not differentiate between those</li>
</ul>
</li>
</ul>
<h3>Threads in Linux (2)</h3>
<ul>
<li>Originally, threads of a process showed up as individual processes in the <code><span class="hljs-attribute">ps</span></code> output</li>
<li>More recent Linux systems (from kernel 2.4) still behave like this, but no longer show separate processes when using <code><span class="hljs-attribute">CLONE_THREAD</span></code></li>
</ul>
<h3>Fibers</h3>
<ul>
<li>Also called user-level threads, green threads or featherweight processes</li>
<li>Implemented on application level only (inside of a process)
<ul>
<li>The operating system doesn't know about fibers</li>
<li>Accordingly, scheduling affects the whole process</li>
</ul>
</li>
<li>Implemented using a library: user level thread package</li>
<li>Advantages:
<ul>
<li>Extremely fast context switch: only exchange processor registers</li>
<li>No switch to kernel mode required to switch to different fiber</li>
<li>Every application can choose the fiber library best suited for it</li>
</ul>
</li>
<li>Disadvantages:
<ul>
<li>Blocking a single fiber leads to blocking the whole process (since the OS doesn't know about fibers)</li>
<li>No speed advantage from multiprocessor systems</li>
</ul>
</li>
</ul>
<h2>Inspiration: Duff's device</h2>
<ul>
<li>Problem: copying 16-bit unsigned integers (&quot;short&quot;s) from an array into  a memory-mapped output register is slow (loop overhead):</li>
</ul>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">send</span>(<span class="hljs-type">short</span> *to, *from, <span class="hljs-type">int</span> count)
{
  <span class="hljs-keyword">do</span> { <span class="hljs-comment">/* count &gt; 0 assumed */</span>
    *to = *from++;
  } <span class="hljs-keyword">while</span> (--count &gt; <span class="hljs-number">0</span>);
}
</code></pre>
<ul>
<li>Optimization: unroll the loop
<ul>
<li>Execute multiple copy operations inside a single loop iteration</li>
<li>Reduces the loop overhead</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">send</span>(<span class="hljs-type">short</span> *to, *from, <span class="hljs-type">int</span> count)
{
  <span class="hljs-keyword">register</span> n = count / <span class="hljs-number">8</span>;
  <span class="hljs-keyword">do</span> {
    *to = *from++;
    *to = *from++;
    *to = *from++;
    *to = *from++;
    *to = *from++;
    *to = *from++;
    *to = *from++;
    *to = *from++;
  } <span class="hljs-keyword">while</span> (--n &gt; <span class="hljs-number">0</span>);
}
</code></pre>
<ul>
<li>Problem with loop unrolling: <code><span class="hljs-built_in">count</span></code> has to be a multiple of 8!</li>
<li>Duff's solution: Introduce a jump into the loop body (using the C switch statement) to implement the first n mod 8 iterations!</li>
</ul>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">send</span>(<span class="hljs-type">short</span> *to, *from, <span class="hljs-type">int</span> count)
{
  <span class="hljs-keyword">register</span> n = (count + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
  <span class="hljs-keyword">switch</span> (count % <span class="hljs-number">8</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">do</span> { *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: *to = *from++;
  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: *to = *from++;
  } <span class="hljs-keyword">while</span> (--n &gt; <span class="hljs-number">0</span>);
} <span class="hljs-comment">// Please do not write code like this..</span>
</code></pre>
<h3>Fibers example: Protothreads</h3>
<ul>
<li>Stackless, lightweight threads, or coroutines
<ul>
<li>Provide a blocking context cheaply using minimal memory per protothread (on the order of single bytes)</li>
<li>Developed by Adam Dunkels (SICS)</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// protothreads implementation: pt.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PT_BEGIN(pt) \
  switch(pt-&gt;lc) { case 0:</span>

<span class="hljs-comment">// … more macros defined …</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PT_WAIT_UNTIL(pt, c) \
  pt-&gt;lc = __LINE__; case __LINE__: \
  <span class="hljs-keyword">if</span>(!(c)) return 0</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pt.h&quot;</span></span>
<span class="hljs-comment">// … protothreads example …</span>
<span class="hljs-built_in">PT_THREAD</span>(<span class="hljs-built_in">example</span>(<span class="hljs-keyword">struct</span> pt *pt)) {
  <span class="hljs-built_in">PT_BEGIN</span>(pt);
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">initiate_io</span>()) {
      <span class="hljs-built_in">timer_start</span>(&amp;timer);
      <span class="hljs-built_in">PT_WAIT_UNTIL</span>(pt,
      <span class="hljs-built_in">io_completed</span>() ||
      <span class="hljs-built_in">timer_expired</span>(&amp;timer));
      <span class="hljs-built_in">read_data</span>();
    }
  }
}
</code></pre>
<h3>Processes vs. threads. vs. fibers</h3>
<table>
<thead>
<tr>
<th>_</th>
<th>Processes</th>
<th>Threads</th>
<th>Fibers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Address space</td>
<td>separate</td>
<td>common</td>
<td>common</td>
</tr>
<tr>
<td>Kernel visibility</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>Scheduling</td>
<td>kernel level</td>
<td>kernel level</td>
<td>user space</td>
</tr>
<tr>
<td>Stack</td>
<td>separate per process</td>
<td>separate per thread</td>
<td>can be common</td>
</tr>
<tr>
<td>Switching overhead</td>
<td>very high</td>
<td>high</td>
<td>low</td>
</tr>
</tbody>
</table>
<h3>Conclusion</h3>
<ul>
<li>Traditional Unix process creation using <code><span class="hljs-attribute">fork</span></code> is too heavyweight for some applications
<ul>
<li>e.g. a heavily used web server</li>
</ul>
</li>
<li>Alternatives exist
<ul>
<li>(kernel-level) threads</li>
<li>(user-level) fibers</li>
</ul>
</li>
<li>Each solution has its own advantages and drawbacks
<ul>
<li>Processes: copy and scheduling overhead</li>
<li>Threads: syncronization difficult to program</li>
<li>Fibers: no kernel management
<ul>
<li>blocking a fiber of a process blocks all fibers</li>
</ul>
</li>
</ul>
</li>
<li>Linux har used the Unix process model exclusively for a long time
<ul>
<li>Windows (NT) didn't have to be compatible and implemented threads from the beginning</li>
</ul>
</li>
</ul>


</article>
</body>
</html>
