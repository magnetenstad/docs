<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>previous_exams.md</title>
    <link rel="icon" type="image/x-icon" href="../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col links">
        
<p><h4><a href="../index.html">courses/</a><a href="./index.html">tdt4205</a>
</h4></p>
<ul>
<li>üìÇ <a href="./assets/index.html">assets</a></li>
<li>üìÑ <a href="lectures.html">lectures</a></li>
<li>üìÑ <a href="previous_exams.html">previous_exams ‚ú®</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#previous-exams-(2010%2C-2011%2C-2016%2C-2017%2C-2018)">Previous Exams (2010, 2011, 2016, 2017, 2018)</a><ol><li><a href="#true-%2F-false">True / False</a></li><li><a href="#topics">Topics</a><ol><li><a href="#lexical-analysis-(lanuages-and-automata)">Lexical analysis (lanuages and automata)</a><ol><li><a href="#2016">2016</a></li><li><a href="#2017">2017</a></li><li><a href="#2018">2018</a></li></ol></li><li><a href="#syntax-analysis">Syntax analysis</a><ol><li><a href="#2010">2010</a></li><li><a href="#2011">2011</a></li><li><a href="#2016-1">2016</a></li><li><a href="#2017-1">2017</a></li><li><a href="#2018-1">2018</a></li></ol></li><li><a href="#intermediate-representation">Intermediate representation</a><ol><li><a href="#2016-2">2016</a></li></ol></li><li><a href="#data-flow-analysis">Data flow analysis</a><ol><li><a href="#2011-1">2011</a></li><li><a href="#2016-3">2016</a></li><li><a href="#2017-2">2017</a></li><li><a href="#2018-2">2018</a></li></ol></li><li><a href="#run-time-environments">Run time environments</a><ol><li><a href="#2010-1">2010</a></li><li><a href="#2016-4">2016</a></li></ol></li><li><a href="#optimizations">Optimizations</a><ol><li><a href="#2011-2">2011</a></li><li><a href="#2018-3">2018</a></li></ol></li><li><a href="#miscellaneous">Miscellaneous</a><ol><li><a href="#2010-2">2010</a><ol><li><a href="#short-answers">Short Answers</a></li><li><a href="#global-variables">Global variables</a></li></ol></li><li><a href="#2011-3">2011</a><ol><li><a href="#relations-and-hasse-diagram">Relations and Hasse diagram</a></li><li><a href="#proof-tree">Proof tree</a></li></ol></li></ol></li></ol></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="previous-exams-(2010%2C-2011%2C-2016%2C-2017%2C-2018)" tabindex="-1">Previous Exams (2010, 2011, 2016, 2017, 2018)</h1>
<h2 id="true-%2F-false" tabindex="-1">True / False</h2>
<p>Spring 2010</p>
<ol>
<li>LR parsing produces a rightmost derivation.</li>
<li>Interfaces (as in Java) specify a dispatch vector layout.</li>
<li>An SLR grammar can not be ambiguous.</li>
<li>It is possible to write a regular expression for the language of regular expressions.</li>
<li>The execution cost of a load instruction is always the same.</li>
<li>A sound type system may reject a type-safe program.</li>
<li>The x86 assembler takes 3-address code as input.</li>
<li>Reaching definitions is a backward analysis.</li>
<li>Adding lookahead symbols increases the size of the corresponding parsing table.</li>
<li>The handle of a right-sentential form is also called a viable prefix.</li>
<li>Reduce/reduce conflicts can commonly be resolved by adding precedence rules to the parsing scheme.</li>
<li>Strong type checking depends on a static type system.</li>
<li>In a control flow graph, the condition of a loop dominates its body.</li>
<li>It is possible to write a context-free grammar for the language of context-free grammars.</li>
<li>Every pair of elements in a partial order must be comparable by the ordering relation.</li>
<li>When a function returns, any values it allocated on heap are no longer valid.</li>
<li>Left factoring a grammar reduces the number of lookahead symbols required to parse it predictively.</li>
<li>When a recursive descent parser verifies any predicted terminal, it already knows which lexeme to expect.</li>
<li>With short-circuit evaluation, binary boolean operators can translate into jumps.</li>
<li>The set of languages recognizable by LALR(k) parsers is smaller than that of LR(k) parsers.</li>
</ol>
<p>Spring 2011</p>
<ol>
<li>With a strongly typed language, type checking will recognize all type-safe programs</li>
<li>A given language corresponds to a unique context-free grammar</li>
<li>LALR(k) parsing can give smaller tables than LR(k)</li>
<li>The meet-over-paths solution to a set of dataflow equations is always at least as precise as the maximal fixed point solution</li>
<li>Variables which are connected in an interference graph can share a register</li>
<li>Every deterministic finite automaton is also a nondeterministic finite automaton</li>
<li>Several different lexemes can correspond to the same token</li>
<li>Moving loop-invariant code to a loop preheader alters the semantics of the program</li>
<li>Grammars with left-recursive productions are not LL(k) parseable for any value of k</li>
<li>At the last control flow point before a return statement, no more than 1 variable may be live</li>
</ol>
<p>Spring 2016</p>
<ol>
<li>All regular languages can be specified by a context-free grammar</li>
<li>Left-recursive productions make a grammar ambiguous</li>
<li>A top-down parser can insert the last node in a syntax tree before it has read the entire source program</li>
<li>LALR(0) parsing admits a greater class of grammars than LR(1) parsing</li>
<li>A program which is accepted by a compiler can not contain any semantic errors</li>
<li>A statically typed programming language admits only type-safe programs</li>
<li>Any C function call with loop-invariant arguments is also loop-invariant</li>
<li>Loop unrolling increases the size of the generated code</li>
<li>The value of a live variable must be stored in a register</li>
<li>A for loop header dominates every statement in the loop body</li>
</ol>
<p>Spring 2017</p>
<ol>
<li>All finite languages are regular languages</li>
<li>Any grammar can be left factored to reduce its lookahead requirement</li>
<li>A static type system can only permit type-safe programs</li>
<li>In order to translate a program into TAC representation, variables must be assigned to CPU registers</li>
<li>L-attributed definitions admit synthesized attributes</li>
<li>The LALR(1) parsing table of a grammar has at most the same number of states as the LR(1) table for the same grammar.</li>
<li>DAG representation of an expression determines exactly one instruction tiling</li>
<li>Common subexpression elimination reduces program size, but does not affect run time.</li>
<li>Two different regular expressions can not match the same language</li>
<li>An interference graph connects variables which are simultaneously live</li>
</ol>
<p>Spring 2018</p>
<ol>
<li>Leftmost and rightmost derivations always correspond to the same syntax tree when the grammar is unambiguous</li>
<li>No left-recursive grammar is LR-parseable</li>
<li>LL(1) parsers need both a nonterminal and a terminal symbol to select a production</li>
<li>Function inlining may increase program size</li>
<li>The subset construction of a DFA from a NFA always results in a DFA with a minimal number of states</li>
<li>In a syntax-directed definition, S-attribution allows inherited attributes</li>
<li>Every operation in a three-address code (TAC) representation must have exactly three operands</li>
<li>The maximal fixed point (MFP) solution to a data flow equation is at least as precise as the Meet-Over-Paths (MOP) solution</li>
<li>Several basic blocks can have the same immediate dominator</li>
<li>Compiled languages can not feature dynamic type checking</li>
</ol>
<h2 id="topics" tabindex="-1">Topics</h2>
<h3 id="lexical-analysis-(lanuages-and-automata)" tabindex="-1">Lexical analysis (lanuages and automata)</h3>
<h4 id="2016" tabindex="-1">2016</h4>
<p>An image file in PPM format contains an ASCII text header, followed by a block of binary data. The header is specified to contain, in sequence: <code><span class="hljs-string">"P6"</span> (<span class="hljs-name">A</span> width*) <span class="hljs-string">"W"</span> <span class="hljs-string">"H"</span> (<span class="hljs-name">A</span> height*) <span class="hljs-string">"M"</span> (<span class="hljs-name">A</span> maximal color value*)</code> *formatted as a decimal number in plain text.</p>
<p>These 7 elements are all separated by arbitrary strings of whitespace, consisting of space, newline, and tabulator characters. The data block contains a sequence of (height * width) triplets of data elements, which are 8-bit values if the maximal color value is 255 or less, and 16-bit values otherwise.</p>
<ol>
<li>Draw a deterministic finite automaton which accepts the header format.</li>
<li>Can PPM files be validated by matching them against a regular expression? Justify your answer.</li>
</ol>
<h4 id="2017" tabindex="-1">2017</h4>
<ol>
<li>Write a regular expression for the language consisting of the three words ‚Äúlower‚Äù, ‚Äúslower‚Äù and ‚Äúshallow‚Äù</li>
<li>Draw a corresponding DFA</li>
<li>Can the number of states in your DFA be reduced? Justify your answer</li>
<li>Write a context-free grammar for the specified header format:
Files in the NIST matrix exchange format begin with a header of 3 words from 3 sets, which are (in order) {coordinate, array}, {real, integer, complex, pattern}, and {general, symmetric, skew-symmetric, Hermitian}. If the last word is 'Hermitian', the 2nd word must be 'complex'. If the 2nd word is 'pattern', the 1st word must be 'coordinate', and the 3rd must be either 'general' or 'symmetric'.</li>
<li>Can this header be recognized by a regular expression? Why/why not?</li>
</ol>
<h4 id="2018" tabindex="-1">2018</h4>
<p>The following lexical definition describes integer constants in the 1989 ANSI C standard:
"An integer constant consisting of a sequence of digits is taken to be octal if it begins with 0
(digit zero), decimal otherwise. Octal constants do not contain the digits 8 or 9. A sequence of
digits preceded by 0x [or] 0X (digit zero) is taken to be a hexadecimal integer. The hexadecimal
digits include a or A through f or F with values 10 through 15. An integer constant may be
suffixed by the letter u or U, to specify that it is unsigned. It may also be suffixed by the letter l or
L, to specify that it is long."</p>
<p>For brevity, assume that the letters {x, a-f, u, l} are case-insensitive, and let ' ? ' denote zero-or-one selection in regular expressions. Note that the optional suffix letters 'l' and 'u' may appear in any combination and order.</p>
<ol>
<li>Write three regular expressions that match octal, hexadecimal, and decimal integer constants, respectively.</li>
<li>Draw a DFA that matches all three types of integer constants.</li>
</ol>
<h3 id="syntax-analysis" tabindex="-1">Syntax analysis</h3>
<h4 id="2010" tabindex="-1">2010</h4>
<pre><code class="hljs language-txt">S ‚Üí XxXy | YyYx
X ‚Üí Œµ
Y ‚Üí Œµ
</code></pre>
<ol>
<li>Show the LL(1) parsing table</li>
<li>Write out the steps in a top-down parse of the input 'xy', showing remaining input, and the state of the parse stack for each step</li>
<li>Write out the steps in a bottom-up parse of the input 'xy', showing remaining input, state of the parse stack, and the action taken for each step</li>
</ol>
<h4 id="2011" tabindex="-1">2011</h4>
<pre><code class="hljs language-txt">S ‚Üí s C T | s C T w B
C ‚Üí c
T ‚Üí t | Œµ
B ‚Üí B a | a
</code></pre>
<ol>
<li>Rewrite this grammar for LL(1) parsing, by left factoring it and eliminating left recursion</li>
<li>Tabulate the FIRST and FOLLOW sets of the nonterminals in the resulting grammar, and construct the predictive parsing table</li>
<li>By default, yacc resolves shift/reduce conflicts by shifting. Briefly explain the consequence of resolving these by reducing instead, using the dangling-else ambiguity as an example</li>
</ol>
<h4 id="2016-1" tabindex="-1">2016</h4>
<pre><code class="hljs language-txt">B ‚Üí b D L e
D ‚Üí v V | Œµ
V ‚Üí i | V i
L ‚Üí S | L S
S ‚Üí B | s
</code></pre>
<p>The grammar fragment above abstracts VSL blocks which contain an optional list of declarations, and a list of one or more statements, where a statement may be a nested block.</p>
<ol>
<li>Rewrite the grammar so that it is LL(1)</li>
<li>Tabulate the FIRST and FOLLOW sets of the nonterminals in the resulting grammar</li>
<li>Construct the predictive parsing table</li>
</ol>
<h4 id="2017-1" tabindex="-1">2017</h4>
<ol>
<li>
<p>Ignoring whitespace and using single characters as terminals, write a context-free grammar for the language of comma-separated lists of integers, where each integer has an optional ‚Äò-‚Äô prefix, and no integer begins with ‚Äò0‚Äô.</p>
</li>
<li>
<p>Is your grammar from the previous task LL(1)? Justify your answer.</p>
</li>
<li>
<p>Given the following grammar for comma-separated lists of items, Draw its LR(0) automaton:</p>
<pre><code class="hljs language-txt">S ‚Üí L
L ‚Üí L , I
L ‚Üí I
I ‚Üí i
</code></pre>
</li>
<li>
<p>Identify any shift/reduce conflict, and show the corresponding SLR parsing table.</p>
</li>
</ol>
<h4 id="2018-1" tabindex="-1">2018</h4>
<ol>
<li>
<p>Adapt the following grammar for LL(1) parsing, by left factoring it</p>
<pre><code class="hljs language-txt">L -&gt; S | S ; L
S -&gt; f V i W L e | s
V -&gt; v
W -&gt; V | V : W
</code></pre>
</li>
<li>
<p>Tabulate the FIRST and FOLLOW sets of each nonterminal in the resulting grammar</p>
</li>
<li>
<p>Construct its LL(1) parsing table</p>
</li>
<li>
<p>Consider the following grammar where i denotes a digit from 0 through 9.</p>
<pre><code class="hljs language-txt">E ‚Üí E + E
E ‚Üí E * E
E ‚Üí i
</code></pre>
<p>Draw the LR(0) automaton, and identify all shift/reduce conflicts</p>
</li>
<li>
<p>Can the ambiguity in this grammar be resolved by SLR parsing? Justify your answer.</p>
</li>
<li>
<p>The grammar abstracts a fragment of the arithmetic rules in VSL. How can its ambiguity be
resolved using the YACC parser generator?</p>
</li>
</ol>
<h3 id="intermediate-representation" tabindex="-1">Intermediate representation</h3>
<h4 id="2016-2" tabindex="-1">2016</h4>
<ol>
<li>Some languages feature a WHERE construct, which applies operations to arrays only where the elements meet a condition, e.g. if 'a' is the array <code><span class="hljs-string">[1,2,3,4]</span></code>, the statement <code>WHERE ( <span class="hljs-keyword">a</span> &lt; <span class="hljs-number">3</span> ) <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span> * <span class="hljs-number">5</span></code> will result in the array <code><span class="hljs-string">[5,10,3,4]</span></code>. Outline a procedure to translate the control flow of WHERE statements into three-address code, using the above statement as an example</li>
</ol>
<h3 id="data-flow-analysis" tabindex="-1">Data flow analysis</h3>
<h4 id="2011-1" tabindex="-1">2011</h4>
<p>Consider the following program fragment</p>
<pre><code class="hljs language-c">x = <span class="hljs-number">7</span>
<span class="hljs-keyword">if</span> ( a ) {
    x = <span class="hljs-number">8</span>
    <span class="hljs-keyword">if</span> ( b ) {
        x = <span class="hljs-number">9</span>
    }
}
y = <span class="hljs-number">2</span> * x
</code></pre>
<ol>
<li>Draw its control flow graph</li>
<li>Label the blocks, and draw the dominator tree</li>
<li>Number the appropriate statements, and label the graph with corresponding in, out, gen and kill sets for reaching definitions analysis. (Block level is sufficient, it is not necessary to show the control points before and after every statement.)</li>
<li>What is the significance of having a monotonic transfer function?</li>
<li>What is the significance of having a distributive transfer function?</li>
</ol>
<h4 id="2016-3" tabindex="-1">2016</h4>
<p>Consider the following program fragment:</p>
<pre><code class="hljs language-c"><span class="hljs-keyword">if</span> ( a ) {
    w = <span class="hljs-number">4</span>;
    x = <span class="hljs-number">3</span>;
    y = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">if</span> ( b ) {
        w = <span class="hljs-number">2</span>;
        x = <span class="hljs-number">2</span>;
        y = <span class="hljs-number">9</span>;
    }
} <span class="hljs-keyword">else</span> {
    w = <span class="hljs-number">2</span>;
    x = <span class="hljs-number">6</span>;
    y = <span class="hljs-number">3</span>;
}

z = w * x * y;
</code></pre>
<ol>
<li>Draw its control flow graph</li>
<li>Consider the dataflow equations of the constant propagation framework. What is the maximal fixed point (MFP) solution for z at the final program point in the graph?</li>
<li>What is the meet-over-paths (MOP) solution for z at the same point?</li>
<li>In your own words, briefly explain the condition under which MFP and MOP solutions are equal.</li>
</ol>
<h4 id="2017-2" tabindex="-1">2017</h4>
<ol>
<li>
<p>Consider the following program fragment, Draw its control flow graph</p>
<pre><code class="hljs language-c">q = <span class="hljs-number">0</span>
i = <span class="hljs-number">0</span>
<span class="hljs-keyword">do</span> {
    i = getchar();
    <span class="hljs-keyword">if</span> ( i == EOF ) { q = <span class="hljs-number">1</span>; }
} <span class="hljs-keyword">while</span> ( q == <span class="hljs-number">0</span> );
<span class="hljs-built_in">exit</span> ( <span class="hljs-number">0</span> );
</code></pre>
</li>
<li>
<p>The post-dominator relation and immediate post-dominator are defined as the dominator
relation and immediate dominator respectively, when applied as a backward analysis.
Write the post-dominator data flow equations for the control flow graph in the previous task,
solve them, and show the corresponding post-dominator tree.</p>
</li>
<li>
<p>Are the Maximal Fixed Point and Meet-Over-Paths solutions equal for this analysis? Justify
your answer.</p>
</li>
<li>
<p>Draw the control flow graph of an equivalent program where the loop condition dominates the
loop body in a forward analysis.</p>
</li>
</ol>
<h4 id="2018-2" tabindex="-1">2018</h4>
<p>Consider the following program fragment:</p>
<pre><code class="hljs language-c">d = <span class="hljs-number">1</span>
c = <span class="hljs-number">2</span>
b = <span class="hljs-number">3</span>
a = <span class="hljs-number">4</span>
loop:
    c = a + b
    d = a + c
    b = c + d
    a = b + d
<span class="hljs-keyword">if</span> (a-b != <span class="hljs-number">13</span>) <span class="hljs-keyword">goto</span> loop
<span class="hljs-built_in">exit</span>
</code></pre>
<ol>
<li>Draw its control flow graph</li>
<li>State and solve the data flow equations for Live Variable analysis. (Assume that no variables are live after exit.)</li>
<li>An interference graph is an undirected graph containing a node for each variable, and connecting edges between nodes which correspond to variables that are live simultaneously. Draw the interference graph for your result from 2..</li>
</ol>
<h3 id="run-time-environments" tabindex="-1">Run time environments</h3>
<h4 id="2010-1" tabindex="-1">2010</h4>
<ol>
<li>Draw the layout of a process image at run time, labelling each part</li>
<li>Draw the layout of an activation record, labelling each part</li>
</ol>
<h4 id="2016-4" tabindex="-1">2016</h4>
<ol>
<li>At the instruction level, describe the steps take to execute a function call in a stack-based machine, and relate them to the layout of an activation record</li>
</ol>
<h3 id="optimizations" tabindex="-1">Optimizations</h3>
<h4 id="2011-2" tabindex="-1">2011</h4>
<p>In C, sqrt is an external library function, whereas in FORTRAN, it is an intrinsic operation defined by the language. Briefly explain which difference this makes to an optimizing compiler when analyzing a loop like the following one</p>
<pre><code class="hljs language-c">x = <span class="hljs-number">2.0</span>

<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; N; i++ ) {
    a[i] = b[i] * <span class="hljs-built_in">sqrt</span>(x)
}
</code></pre>
<h4 id="2018-3" tabindex="-1">2018</h4>
<p>Consider the following program fragment</p>
<pre><code class="hljs language-c"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; M; i++ ) {
    <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; N; j++ ) {
        C[i][j] = <span class="hljs-number">0.0</span>;

        <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; N; k++ ) {
            C[i][j] += A[i][k] * B[k][j];
        }
    }
}
</code></pre>
<ol>
<li>Assume that N is an even number, and rewrite the innermost, k-indexed loop when it is unrolled by a factor 2.</li>
<li>Briefly explain the purpose and effect of strength reduction</li>
<li>Explain why constant folding and propagation may be usefully applied several times to a given program.</li>
</ol>
<h3 id="miscellaneous" tabindex="-1">Miscellaneous</h3>
<h4 id="2010-2" tabindex="-1">2010</h4>
<h5 id="short-answers" tabindex="-1">Short Answers</h5>
<ol>
<li>Briefly explain the distinction between L-attributed and S-attributed syntax-directed definitions</li>
<li>Under what condition is the maximal fixed point solution to a dataflow problem identical to the meet-over-paths solution?</li>
<li>How is the Œµ-closure of an NFA state defined?</li>
<li>Can a language with pointer arithmetic feature automatic garbage collection? Justify your answer</li>
<li>State two advantages obtained by function inlining</li>
<li>How can register assignment benefit from live variable analysis?</li>
<li>Most programs exhibit some degree of spatial and temporal locality. Explain what these two terms refer to, and how they may be exploited for efficient execution</li>
<li>LL(k) parsing can be extended to an unbounded amount of lookahead by allowing the parser to decide the choice of production based on testing the remaining token stream against a finite set of regular languages. Does this resolve the problem with left-recursion? Explain</li>
<li>Explain the cause and effect of heap memory fragmentation</li>
<li>Identify the loop-invariant code in the following program fragment, and explain the benefit of moving it</li>
</ol>
<pre><code class="hljs language-c"><span class="hljs-type">double</span> s[<span class="hljs-number">180</span>], pi = M_PI;

<span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">180</span>; d++ ) {
    s[d] = <span class="hljs-built_in">sin</span> ( d * pi / <span class="hljs-number">180.0</span> );
}
</code></pre>
<h5 id="global-variables" tabindex="-1">Global variables</h5>
<p>Briefly describe which changes you would make to your compiler from the TDT4205 problem sets, in order to extend VSL with global variables</p>
<h4 id="2011-3" tabindex="-1">2011</h4>
<h5 id="relations-and-hasse-diagram" tabindex="-1">Relations and Hasse diagram</h5>
<ol>
<li>Define a relation for ordered pairs of integers { (a,b), (c,d) }, such that (a_b) &lt; (c_d)</li>
<li>Draw a Hasse diagram for the order this imposes on the set of pairs { (0,0), (1,0), (0,1), (1,1), (1,2), (2,1), (2,2) }</li>
<li>Mark the greatest lower bound for (1,2) and (2,1).</li>
<li>Does this pair of set and ordering relation form a lattice? Justify your answer.</li>
</ol>
<h5 id="proof-tree" tabindex="-1">Proof tree</h5>
<p><img src="assets/2023-05-16-18-36-39.png" alt=""></p>
<p>and the premises that 2:int and 3.14:float, show a proof tree with judgements on the types of x and y in the statement: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">?</mo><mi>y</mi><mo>:</mo><mn>3.14</mn></mrow><annotation encoding="application/x-tex">(x&gt;2) ? y : 3.14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">?</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span></span></span></span></p>

        <div style="height: 100vh;"></div>
      </article>
      </div>
  </body>
</html>
