<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>08.md</title>
    <link rel="icon" type="image/x-icon" href="../../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col">
        
<p><h4><a href="../index.html">tdt4258/</a><a href="./index.html">lectures</a>
</h4></p>
<ul>
<li>ğŸ“‚ <a href="./assets/index.html">assets</a></li>
<li>ğŸ“„ <a href="01.html">01</a></li>
<li>ğŸ“„ <a href="02.html">02</a></li>
<li>ğŸ“„ <a href="03.html">03</a></li>
<li>ğŸ“„ <a href="04.html">04</a></li>
<li>ğŸ“„ <a href="05.html">05</a></li>
<li>ğŸ“„ <a href="06.html">06</a></li>
<li>ğŸ“„ <a href="07.html">07</a></li>
<li>ğŸ“„ <a href="08.html">08 âœ¨</a></li>
<li>ğŸ“„ <a href="09.html">09</a></li>
<li>ğŸ“„ <a href="10.html">10</a></li>
<li>ğŸ“„ <a href="11.html">11</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#compilation-and-optimizations">Compilation and Optimizations</a><ol><li><a href="#intro-to-compilers">Intro to Compilers</a><ol><li><a href="#overview">Overview</a></li><li><a href="#declaration-vs-definition">Declaration vs Definition</a></li></ol></li><li><a href="#compilers-frontend">Compilers Frontend</a><ol><li><a href="#compilers">Compilers</a></li><li><a href="#detailed-compilation-flow">Detailed Compilation Flow</a></li><li><a href="#the-c-pre-processor">The C pre-processor</a></li><li><a href="#anatomy-of-a-modern-compiler">Anatomy of a Modern Compiler</a><ol><li><a href="#frontend-(analysis)">Frontend (analysis)</a></li><li><a href="#back-end-(synthesis)">Back-end (synthesis)</a></li></ol></li><li><a href="#frontend-stages">Frontend Stages</a></li></ol></li><li><a href="#intermediate-representation">Intermediate Representation</a><ol><li><a href="#data-flow-graph-(dfg)">Data flow graph (DFG)</a></li><li><a href="#static-single-assignment-(ssa)">Static Single Assignment (SSA)</a></li><li><a href="#dfg-and-partial-orders">DFG and Partial Orders</a></li></ol></li><li><a href="#optimizations">Optimizations</a><ol><li><a href="#control-data-flow-graph-(cdfg)">Control-Data Flow Graph (CDFG)</a></li><li><a href="#ir-optimization">IR Optimization</a></li></ol></li><li><a href="#code-generation">Code Generation</a></li><li><a href="#loop-transformations">Loop Transformations</a></li><li><a href="#register-allocation">Register Allocation</a></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="compilation-and-optimizations" tabindex="-1">Compilation and Optimizations</h1>
<ul>
<li>Chapter 5 (5.1 - 5.7)</li>
</ul>
<h2 id="intro-to-compilers" tabindex="-1">Intro to Compilers</h2>
<h3 id="overview" tabindex="-1">Overview</h3>
<p>â–ª Programs are divided into compilation units
â€“ Provide degree of modularity
â€“ Each commonly has main file (.c) for source code
â€“ Header files (.h) declare public interfaces of units
â–ª Each unit is compiled separately to relocatable object code
â€“ Allows creation of object-code libraries
â–ª A linker combines these into an executable, resolving references between units
â–ª A loader sets up the executable program in memory and initialises data areas, prior to the program being run</p>
<h3 id="declaration-vs-definition" tabindex="-1">Declaration vs Definition</h3>
<p>â–ª Declaration: inform the compiler of the existence of a
variable or function</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>; <span class="hljs-comment">// in .h file</span>
</code></pre>
<p>â–ª Definition: provide function body; allocate memory for
local variables</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> { <span class="hljs-comment">// in .c file</span>
 <span class="hljs-type">int</span> temp = *a;
 *a = *b;
 *b = temp;
}
</code></pre>
<h2 id="compilers-frontend" tabindex="-1">Compilers Frontend</h2>
<h3 id="compilers" tabindex="-1">Compilers</h3>
<p>â€¢ Bare minimum for a functional compiler</p>
<p><img src="assets/2022-11-21-15-36-16.png" alt=""></p>
<p>â€¢ Good compilers
o Produce meaningful errors on incorrect programs
o Produce fast, optimized code</p>
<h3 id="detailed-compilation-flow" tabindex="-1">Detailed Compilation Flow</h3>
<p><img src="assets/2022-11-21-15-37-03.png" alt=""></p>
<h3 id="the-c-pre-processor" tabindex="-1">The C pre-processor</h3>
<p>â–ª Includes â€“ imports header files</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>â–ª Text substitution, e.g. define constants</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME value</span>
</code></pre>
<p>â–ª Macros (inline functions)</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(X,Y) (X&gt;Y ? X : Y) <span class="hljs-comment">// careful with macros!</span></span>
</code></pre>
<p>â–ª Conditional compilation</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Debugging message"</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// $ gcc -DDEBUG</span>
</code></pre>
<p>â–ª Inserts header files to C source code file in response to</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>â–ª Performs macro substitution
â€“ E.g. In response to <code><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">CONST</span> <span class="hljs-number">5</span></span></code>
â€“ All references to CONST in source will be replaced by 5
â–ª No type checking or anything, just a direct textual replacement
â–ª To examine the output gcc pre-processor <code><span class="hljs-symbol">$</span> gcc â€“E <span class="hljs-keyword">file</span>.c â€“o output.c</code></p>
<h3 id="anatomy-of-a-modern-compiler" tabindex="-1">Anatomy of a Modern Compiler</h3>
<p><img src="assets/2022-11-21-15-45-08.png" alt=""></p>
<h4 id="frontend-(analysis)" tabindex="-1">Frontend (analysis)</h4>
<p>â€¢ Read source program
â€¢ Break it up into basic elements
â€¢ Check correctness, report errors
â€¢ Translate to generic intermediate representation (IR)</p>
<h4 id="back-end-(synthesis)" tabindex="-1">Back-end (synthesis)</h4>
<p>â€¢ Optimize IR
â€¢ Translate IR to ASM
â€¢ Optimize ASM</p>
<h3 id="frontend-stages" tabindex="-1">Frontend Stages</h3>
<p>â€¢ Lexical analysis (scanning): Source -&gt; List of tokens
â€¢ Syntactic analysis (parsing): Tokens -&gt; Syntax tree
â€¢ Semantic analysis (mainly, type checking)</p>
<h2 id="intermediate-representation" tabindex="-1">Intermediate Representation</h2>
<p>â€¢ Internal compiler language that is:
â—‹ Language-independent
â—‹ Machine-independent
â—‹ Easy to optimize
â€¢ Why yet another language?
â—‹ Assembly does not have enough info to optimize it well
â—‹ Enables modularity and reuse</p>
<p><img src="assets/2022-11-21-15-53-03.png" alt=""></p>
<h3 id="data-flow-graph-(dfg)" tabindex="-1">Data flow graph (DFG)</h3>
<p>â–ª Represents flow of data inside â€œbasic blockâ€
â–ª Basic blocks
â€“ Code with one entry one exit
â€“ May have a branch at the end, not before
â–ª Does not represent control.
â–ª Describes the minimal ordering requirements on operations.
â–ª Static Single Assignment is employed to ease optimizations</p>
<h3 id="static-single-assignment-(ssa)" tabindex="-1">Static Single Assignment (SSA)</h3>
<p>â–ª If a variable is assigned more that once in the source code:
â€“ SSA keeps only the first assignment
â€“ The rest of the assignments are renamed to temporary variables</p>
<p><img src="assets/2022-11-21-15-57-42.png" alt=""></p>
<h3 id="dfg-and-partial-orders" tabindex="-1">DFG and Partial Orders</h3>
<p><img src="assets/2022-11-21-15-58-56.png" alt=""></p>
<h2 id="optimizations" tabindex="-1">Optimizations</h2>
<h3 id="control-data-flow-graph-(cdfg)" tabindex="-1">Control-Data Flow Graph (CDFG)</h3>
<p>â–ª Represents control and data flow
â€“ Nodes: basic blocks
â€“ Edges: branches between basic blocks</p>
<p><img src="assets/2022-11-21-16-01-05.png" alt="">
<img src="assets/2022-11-21-16-01-35.png" alt=""></p>
<h3 id="ir-optimization" tabindex="-1">IR Optimization</h3>
<p>â–ª Machine independent optimizations
â€“ Code optimizations independent of the target architecture
â€“ e.g. dead code elimination, constant propagation, constant folding etc.
â–ª Machine dependent optimizations
â€“ Specifically aim at target architecture
â€“ May not be applicable directly across different architectures
â€“ e.g. Instruction selection, register allocation etc.
â–ª Perform a set of passes over the CFG
â€“ Each pass does a specific, simple task over the CFG
â€“ By repeating multiple simple passes on the CFG over and over, compilers achieve very complex optimizations
â–ª Example optimizations:
â€“ Dead code elimination: Eliminate assignments to variables that are never used, or basic blocks that are never reached
â€“ Constant propagation: Identify variables that are constant, substitute the constant elsewhere
â€“ Constant folding: Compute and substitute constant expressions</p>
<h2 id="code-generation" tabindex="-1">Code Generation</h2>
<p>â–ª Translate optimized IR to assembly
â–ª Register allocation: Map variable to registers
â€“ If #variables &gt; #registers, map some to memory and load/store when needed
â–ª Translate each assignment to instruction
â€“ Some assignments may require more than one instruction if ISA does not have operations
â–ª Emit each basic block: labels, assignments and branches
â–ª Lay out basic blocks, remove superfluous branches
â–ª ISA and CPU specific optimization
â€“ E.g. reorder instructions if possible</p>
<h2 id="loop-transformations" tabindex="-1">Loop Transformations</h2>
<h2 id="register-allocation" tabindex="-1">Register Allocation</h2>

      </article>
      </div>
  </body>
</html>
