<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>08.md</title>
    <link rel="icon" type="image/x-icon" href="../../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col links">
        
<p><h4><a href="../index.html">tdt4258/</a><a href="./index.html">lectures</a>
</h4></p>
<ul>
<li>📂 <a href="./assets/index.html">assets</a></li>
<li>📄 <a href="01.html">01</a></li>
<li>📄 <a href="02.html">02</a></li>
<li>📄 <a href="03.html">03</a></li>
<li>📄 <a href="04.html">04</a></li>
<li>📄 <a href="05.html">05</a></li>
<li>📄 <a href="06.html">06</a></li>
<li>📄 <a href="07.html">07</a></li>
<li>📄 <a href="08.html">08 ✨</a></li>
<li>📄 <a href="09.html">09</a></li>
<li>📄 <a href="10.html">10</a></li>
<li>📄 <a href="11.html">11</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#compilation-and-optimizations">Compilation and Optimizations</a><ol><li><a href="#intro-to-compilers">Intro to Compilers</a><ol><li><a href="#overview">Overview</a></li><li><a href="#declaration-vs-definition">Declaration vs Definition</a></li></ol></li><li><a href="#compilers-frontend">Compilers Frontend</a><ol><li><a href="#compilers">Compilers</a></li><li><a href="#detailed-compilation-flow">Detailed Compilation Flow</a></li><li><a href="#the-c-pre-processor">The C pre-processor</a></li><li><a href="#anatomy-of-a-modern-compiler">Anatomy of a Modern Compiler</a><ol><li><a href="#frontend-(analysis)">Frontend (analysis)</a></li><li><a href="#back-end-(synthesis)">Back-end (synthesis)</a></li></ol></li><li><a href="#frontend-stages">Frontend Stages</a></li></ol></li><li><a href="#intermediate-representation">Intermediate Representation</a><ol><li><a href="#data-flow-graph-(dfg)">Data flow graph (DFG)</a></li><li><a href="#static-single-assignment-(ssa)">Static Single Assignment (SSA)</a></li><li><a href="#dfg-and-partial-orders">DFG and Partial Orders</a></li></ol></li><li><a href="#optimizations">Optimizations</a><ol><li><a href="#control-data-flow-graph-(cdfg)">Control-Data Flow Graph (CDFG)</a></li><li><a href="#ir-optimization">IR Optimization</a></li></ol></li><li><a href="#code-generation">Code Generation</a></li><li><a href="#summary%3A-modern-compilers">Summary: Modern Compilers</a></li><li><a href="#loop-transformations">Loop Transformations</a><ol><li><a href="#%231%3A-loop-unrolling">#1: Loop Unrolling</a></li><li><a href="#%232%3A-loop-fusion">#2: Loop Fusion</a></li><li><a href="#%233%3A-loop-distribution%2Ffission">#3: Loop Distribution/Fission</a></li><li><a href="#%234%3A-loop-interchange">#4: Loop Interchange</a></li><li><a href="#%235%3A-loop-tiling">#5: Loop Tiling</a></li></ol></li><li><a href="#function-inlining-and-register-allocation">Function Inlining and Register Allocation</a><ol><li><a href="#procedure%2Ffunction-inlining">Procedure/Function Inlining</a></li><li><a href="#register-allocation">Register Allocation</a></li><li><a href="#register-allocation-with-graph-coloring">Register Allocation with Graph Coloring</a></li><li><a href="#instruction-selection">Instruction Selection</a></li></ol></li><li><a href="#assembler-and-linker">Assembler and linker</a><ol><li><a href="#symbol-table">Symbol Table</a></li><li><a href="#object-file">Object File</a></li><li><a href="#linker">Linker</a><ol><li><a href="#dynamic-linking">Dynamic Linking</a></li></ol></li></ol></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="compilation-and-optimizations" tabindex="-1">Compilation and Optimizations</h1>
<ul>
<li>Chapter 5 (5.1 - 5.7)</li>
</ul>
<h2 id="intro-to-compilers" tabindex="-1">Intro to Compilers</h2>
<h3 id="overview" tabindex="-1">Overview</h3>
<p>▪ Programs are divided into compilation units
– Provide degree of modularity
– Each commonly has main file (.c) for source code
– Header files (.h) declare public interfaces of units
▪ Each unit is compiled separately to relocatable object code
– Allows creation of object-code libraries
▪ A linker combines these into an executable, resolving references between units
▪ A loader sets up the executable program in memory and initialises data areas, prior to the program being run</p>
<h3 id="declaration-vs-definition" tabindex="-1">Declaration vs Definition</h3>
<p>▪ Declaration: inform the compiler of the existence of a
variable or function</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>; <span class="hljs-comment">// in .h file</span>
</code></pre>
<p>▪ Definition: provide function body; allocate memory for
local variables</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> { <span class="hljs-comment">// in .c file</span>
 <span class="hljs-type">int</span> temp = *a;
 *a = *b;
 *b = temp;
}
</code></pre>
<h2 id="compilers-frontend" tabindex="-1">Compilers Frontend</h2>
<h3 id="compilers" tabindex="-1">Compilers</h3>
<p>• Bare minimum for a functional compiler</p>
<p><img src="assets/2022-11-21-15-36-16.png" alt=""></p>
<p>• Good compilers
o Produce meaningful errors on incorrect programs
o Produce fast, optimized code</p>
<h3 id="detailed-compilation-flow" tabindex="-1">Detailed Compilation Flow</h3>
<p><img src="assets/2022-11-21-15-37-03.png" alt=""></p>
<h3 id="the-c-pre-processor" tabindex="-1">The C pre-processor</h3>
<p>▪ Includes – imports header files</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>▪ Text substitution, e.g. define constants</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME value</span>
</code></pre>
<p>▪ Macros (inline functions)</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(X,Y) (X&gt;Y ? X : Y) <span class="hljs-comment">// careful with macros!</span></span>
</code></pre>
<p>▪ Conditional compilation</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Debugging message"</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// $ gcc -DDEBUG</span>
</code></pre>
<p>▪ Inserts header files to C source code file in response to</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>▪ Performs macro substitution
– E.g. In response to <code><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">CONST</span> <span class="hljs-number">5</span></span></code>
– All references to CONST in source will be replaced by 5
▪ No type checking or anything, just a direct textual replacement
▪ To examine the output gcc pre-processor <code><span class="hljs-symbol">$</span> gcc –E <span class="hljs-keyword">file</span>.c –o output.c</code></p>
<h3 id="anatomy-of-a-modern-compiler" tabindex="-1">Anatomy of a Modern Compiler</h3>
<p><img src="assets/2022-11-21-15-45-08.png" alt=""></p>
<h4 id="frontend-(analysis)" tabindex="-1">Frontend (analysis)</h4>
<p>• Read source program
• Break it up into basic elements
• Check correctness, report errors
• Translate to generic intermediate representation (IR)</p>
<h4 id="back-end-(synthesis)" tabindex="-1">Back-end (synthesis)</h4>
<p>• Optimize IR
• Translate IR to ASM
• Optimize ASM</p>
<h3 id="frontend-stages" tabindex="-1">Frontend Stages</h3>
<p>• Lexical analysis (scanning): Source -&gt; List of tokens
• Syntactic analysis (parsing): Tokens -&gt; Syntax tree
• Semantic analysis (mainly, type checking)</p>
<h2 id="intermediate-representation" tabindex="-1">Intermediate Representation</h2>
<p>• Internal compiler language that is:
○ Language-independent
○ Machine-independent
○ Easy to optimize
• Why yet another language?
○ Assembly does not have enough info to optimize it well
○ Enables modularity and reuse</p>
<p><img src="assets/2022-11-21-15-53-03.png" alt=""></p>
<h3 id="data-flow-graph-(dfg)" tabindex="-1">Data flow graph (DFG)</h3>
<p>▪ Represents flow of data inside “basic block”
▪ Basic blocks
– Code with one entry one exit
– May have a branch at the end, not before
▪ Does not represent control.
▪ Describes the minimal ordering requirements on operations.
▪ Static Single Assignment is employed to ease optimizations</p>
<h3 id="static-single-assignment-(ssa)" tabindex="-1">Static Single Assignment (SSA)</h3>
<p>▪ If a variable is assigned more that once in the source code:
– SSA keeps only the first assignment
– The rest of the assignments are renamed to temporary variables</p>
<p><img src="assets/2022-11-21-15-57-42.png" alt=""></p>
<h3 id="dfg-and-partial-orders" tabindex="-1">DFG and Partial Orders</h3>
<p><img src="assets/2022-11-21-15-58-56.png" alt=""></p>
<h2 id="optimizations" tabindex="-1">Optimizations</h2>
<h3 id="control-data-flow-graph-(cdfg)" tabindex="-1">Control-Data Flow Graph (CDFG)</h3>
<p>▪ Represents control and data flow
– Nodes: basic blocks
– Edges: branches between basic blocks</p>
<p><img src="assets/2022-11-21-16-01-05.png" alt="">
<img src="assets/2022-11-21-16-01-35.png" alt=""></p>
<h3 id="ir-optimization" tabindex="-1">IR Optimization</h3>
<p>▪ Machine independent optimizations
– Code optimizations independent of the target architecture
– e.g. dead code elimination, constant propagation, constant folding etc.
▪ Machine dependent optimizations
– Specifically aim at target architecture
– May not be applicable directly across different architectures
– e.g. Instruction selection, register allocation etc.
▪ Perform a set of passes over the CFG
– Each pass does a specific, simple task over the CFG
– By repeating multiple simple passes on the CFG over and over, compilers achieve very complex optimizations
▪ Example optimizations:
– Dead code elimination: Eliminate assignments to variables that are never used, or basic blocks that are never reached
– Constant propagation: Identify variables that are constant, substitute the constant elsewhere
– Constant folding: Compute and substitute constant expressions</p>
<h2 id="code-generation" tabindex="-1">Code Generation</h2>
<p>▪ Translate optimized IR to assembly
▪ Register allocation: Map variable to registers
– If #variables &gt; #registers, map some to memory and load/store when needed
▪ Translate each assignment to instruction
– Some assignments may require more than one instruction if ISA does not have operations
▪ Emit each basic block: labels, assignments and branches
▪ Lay out basic blocks, remove superfluous branches
▪ ISA and CPU specific optimization
– E.g. reorder instructions if possible</p>
<h2 id="summary%3A-modern-compilers" tabindex="-1">Summary: Modern Compilers</h2>
<p><img src="assets/2022-11-25-11-04-21.png" alt=""></p>
<h2 id="loop-transformations" tabindex="-1">Loop Transformations</h2>
<p>▪ Why is it important
– Programs spends lots of time in loops
▪ Goal
– Reduce loop overhead
– Increase opportunities for other optimizations
– Improve pipeline and memory system performance</p>
<h3 id="%231%3A-loop-unrolling" tabindex="-1">#1: Loop Unrolling</h3>
<p>▪ Duplicates loop body ‘n’ times and adjust loop bounds
– Reduces number of comparisons/branches to test loop exit
• Branches are big performance bottleneck in hardware
– Increases loop body size
• Enables more optimizations
• More register pressure</p>
<p><img src="assets/2022-11-25-11-12-20.png" alt=""></p>
<h3 id="%232%3A-loop-fusion" tabindex="-1">#2: Loop Fusion</h3>
<p>▪ Combines two (or more) loops into one</p>
<ul>
<li>Pros:
<ul>
<li>May improve data locality</li>
<li>Reduces loop overhead</li>
<li>May enable better instruction scheduling</li>
</ul>
</li>
<li>Cons:
<ul>
<li>May hurt data locality</li>
<li>May hurt I-cache hit rate</li>
</ul>
</li>
</ul>
<p><img src="assets/2022-11-25-11-12-33.png" alt=""></p>
<h3 id="%233%3A-loop-distribution%2Ffission" tabindex="-1">#3: Loop Distribution/Fission</h3>
<p>▪ Divides a loop into two (or more) loops</p>
<ul>
<li>Pros:
<ul>
<li>Enables optimizations: 2nd loop is parallel loop</li>
<li>Reduces register pressure</li>
</ul>
</li>
<li>Cons:
<ul>
<li>Increases loop overhead</li>
</ul>
</li>
</ul>
<p><img src="assets/2022-11-25-11-12-42.png" alt=""></p>
<h3 id="%234%3A-loop-interchange" tabindex="-1">#4: Loop Interchange</h3>
<p>▪ Switches the order of loops in a loop nest
▪ Can improve data locality and parallelism</p>
<p><img src="assets/2022-11-25-11-12-50.png" alt=""></p>
<h3 id="%235%3A-loop-tiling" tabindex="-1">#5: Loop Tiling</h3>
<p>▪ Breaks a loop into a set of nested loops
– Each inner loop operates on a subset of data
▪ Changes memory access pattern: Can improve locality</p>
<p><img src="assets/2022-11-25-11-13-47.png" alt=""></p>
<h2 id="function-inlining-and-register-allocation" tabindex="-1">Function Inlining and Register Allocation</h2>
<h3 id="procedure%2Ffunction-inlining" tabindex="-1">Procedure/Function Inlining</h3>
<p>▪ Replaces call with the body of the callee (called function)
▪ Programmer can ask compiler to inline a function
– C provides inline keyword
▪ Compiler itself can inline a function if deemed beneficial</p>
<p><img src="assets/2022-11-25-11-17-33.png" alt=""></p>
<p>▪ Function calls can be costly
– Direct costs: arguments and results passing, call/return (branch) instructions, stack frame maintenance etc
– Indirect costs: breaks intra-procedural analysis to inter-procedural analysis (which is more complex)
▪ Inlining removes these costs
▪ Downside
– Can increases code size
– Can reduce instruction cache hit rate</p>
<h3 id="register-allocation" tabindex="-1">Register Allocation</h3>
<p>▪ Registers temporarily hold variables
▪ Aim: Allocate registers to variables such that memory accesses are minimized
– Good register allocation is key to performance as memory accesses can be costly (imagine cache misses)
▪ Compilers analyze lifetime of variables for register allocation
▪ Programmers could hint which variables to keep in registers
– C supports register keyword
– Modern compilers just ignore it!
▪ Some variables always need to be in memory
– volatile keyword provides this functionality
– Still brought to a register for using the value</p>
<h3 id="register-allocation-with-graph-coloring" tabindex="-1">Register Allocation with Graph Coloring</h3>
<p>▪ Edges between variable that are live at the same time
▪ Represent each register with a color
▪ Color the nodes with as few colors as possible
– No edge must share a color
▪ NP-complete
– Compilers use heuristics to reach a good solution</p>
<h3 id="instruction-selection" tabindex="-1">Instruction Selection</h3>
<p>▪ IR code can be translated to a number instruction
sequences depending types of instructions in ISA
▪ IR expressions are represented as graphs (CDFG)
– Find the best template for expression
– The template should minimize the chosen cost metric</p>
<h2 id="assembler-and-linker" tabindex="-1">Assembler and linker</h2>
<p>▪ Generate machine instructions (binary) from assembly instructions (symbolic)
– One to one translation (usually)
▪ Translate labels into addresses
▪ Handle pseudo-ops
▪ Two pass approach
– First pass: Generate symbol table
– Second pass: resolve labels and generate machine instructions</p>
<h3 id="symbol-table" tabindex="-1">Symbol Table</h3>
<p>▪ Generating symbol table:
– Scan the file to collect labels and their addresses
▪ Addresses are generally relative to the first instructions in
the file</p>
<h3 id="object-file" tabindex="-1">Object File</h3>
<p>▪ Output of assembler
▪ Several standards
– ELF (Unix), ECOFF (Windows), Mach-O (OS X)
▪ Object file includes
– Symbol table
– Program code (.text segment)
– Data (.data segment)
– Information about relocatable parts
– Debug data (references to source files)</p>
<h3 id="linker" tabindex="-1">Linker</h3>
<p>▪ Takes multiple object files and libraries and generates one executable file
– Combines all object file segments (text, data)
– Determines start address for all modules
– Combines all symbol tables
– Resolves all symbols
▪ Transforms relative address to absolute addresses
▪ Produces an error if cannot find a label/symbol in merged symbol table</p>
<h4 id="dynamic-linking" tabindex="-1">Dynamic Linking</h4>
<p>▪ Most operating systems can link modules at load time
– e.g. shared libraries (.so on linux platforms)
– Saves storage space</p>

        <div style="height: 100vh;"></div>
      </article>
      </div>
  </body>
</html>
