<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>08.md</title>
    <link rel="icon" type="image/x-icon" href="../../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col">
        
<p><h4><a href="../index.html">tdt4258/</a><a href="./index.html">lectures</a>
</h4></p>
<ul>
<li>📂 <a href="./assets/index.html">assets</a></li>
<li>📄 <a href="01.html">01</a></li>
<li>📄 <a href="02.html">02</a></li>
<li>📄 <a href="03.html">03</a></li>
<li>📄 <a href="04.html">04</a></li>
<li>📄 <a href="05.html">05</a></li>
<li>📄 <a href="06.html">06</a></li>
<li>📄 <a href="07.html">07</a></li>
<li>📄 <a href="08.html">08 ✨</a></li>
<li>📄 <a href="09.html">09</a></li>
<li>📄 <a href="10.html">10</a></li>
<li>📄 <a href="11.html">11</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#compilation-and-optimizations">Compilation and Optimizations</a><ol><li><a href="#intro-to-compilers">Intro to Compilers</a><ol><li><a href="#overview">Overview</a></li><li><a href="#declaration-vs-definition">Declaration vs Definition</a></li></ol></li><li><a href="#compilers-frontend">Compilers Frontend</a><ol><li><a href="#compilers">Compilers</a></li><li><a href="#detailed-compilation-flow">Detailed Compilation Flow</a></li><li><a href="#the-c-pre-processor">The C pre-processor</a></li><li><a href="#anatomy-of-a-modern-compiler">Anatomy of a Modern Compiler</a><ol><li><a href="#frontend-(analysis)">Frontend (analysis)</a></li><li><a href="#back-end-(synthesis)">Back-end (synthesis)</a></li></ol></li><li><a href="#frontend-stages">Frontend Stages</a></li></ol></li><li><a href="#intermediate-representation">Intermediate Representation</a><ol><li><a href="#data-flow-graph-(dfg)">Data flow graph (DFG)</a></li><li><a href="#static-single-assignment-(ssa)">Static Single Assignment (SSA)</a></li><li><a href="#dfg-and-partial-orders">DFG and Partial Orders</a></li></ol></li><li><a href="#optimizations">Optimizations</a><ol><li><a href="#control-data-flow-graph-(cdfg)">Control-Data Flow Graph (CDFG)</a></li><li><a href="#ir-optimization">IR Optimization</a></li></ol></li><li><a href="#code-generation">Code Generation</a></li><li><a href="#loop-transformations">Loop Transformations</a></li><li><a href="#register-allocation">Register Allocation</a></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="compilation-and-optimizations" tabindex="-1">Compilation and Optimizations</h1>
<ul>
<li>Chapter 5 (5.1 - 5.7)</li>
</ul>
<h2 id="intro-to-compilers" tabindex="-1">Intro to Compilers</h2>
<h3 id="overview" tabindex="-1">Overview</h3>
<p>▪ Programs are divided into compilation units
– Provide degree of modularity
– Each commonly has main file (.c) for source code
– Header files (.h) declare public interfaces of units
▪ Each unit is compiled separately to relocatable object code
– Allows creation of object-code libraries
▪ A linker combines these into an executable, resolving references between units
▪ A loader sets up the executable program in memory and initialises data areas, prior to the program being run</p>
<h3 id="declaration-vs-definition" tabindex="-1">Declaration vs Definition</h3>
<p>▪ Declaration: inform the compiler of the existence of a
variable or function</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>; <span class="hljs-comment">// in .h file</span>
</code></pre>
<p>▪ Definition: provide function body; allocate memory for
local variables</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> { <span class="hljs-comment">// in .c file</span>
 <span class="hljs-type">int</span> temp = *a;
 *a = *b;
 *b = temp;
}
</code></pre>
<h2 id="compilers-frontend" tabindex="-1">Compilers Frontend</h2>
<h3 id="compilers" tabindex="-1">Compilers</h3>
<p>• Bare minimum for a functional compiler</p>
<p><img src="assets/2022-11-21-15-36-16.png" alt=""></p>
<p>• Good compilers
o Produce meaningful errors on incorrect programs
o Produce fast, optimized code</p>
<h3 id="detailed-compilation-flow" tabindex="-1">Detailed Compilation Flow</h3>
<p><img src="assets/2022-11-21-15-37-03.png" alt=""></p>
<h3 id="the-c-pre-processor" tabindex="-1">The C pre-processor</h3>
<p>▪ Includes – imports header files</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>▪ Text substitution, e.g. define constants</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME value</span>
</code></pre>
<p>▪ Macros (inline functions)</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(X,Y) (X&gt;Y ? X : Y) <span class="hljs-comment">// careful with macros!</span></span>
</code></pre>
<p>▪ Conditional compilation</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Debugging message"</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// $ gcc -DDEBUG</span>
</code></pre>
<p>▪ Inserts header files to C source code file in response to</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>▪ Performs macro substitution
– E.g. In response to <code><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">CONST</span> <span class="hljs-number">5</span></span></code>
– All references to CONST in source will be replaced by 5
▪ No type checking or anything, just a direct textual replacement
▪ To examine the output gcc pre-processor <code><span class="hljs-symbol">$</span> gcc –E <span class="hljs-keyword">file</span>.c –o output.c</code></p>
<h3 id="anatomy-of-a-modern-compiler" tabindex="-1">Anatomy of a Modern Compiler</h3>
<p><img src="assets/2022-11-21-15-45-08.png" alt=""></p>
<h4 id="frontend-(analysis)" tabindex="-1">Frontend (analysis)</h4>
<p>• Read source program
• Break it up into basic elements
• Check correctness, report errors
• Translate to generic intermediate representation (IR)</p>
<h4 id="back-end-(synthesis)" tabindex="-1">Back-end (synthesis)</h4>
<p>• Optimize IR
• Translate IR to ASM
• Optimize ASM</p>
<h3 id="frontend-stages" tabindex="-1">Frontend Stages</h3>
<p>• Lexical analysis (scanning): Source -&gt; List of tokens
• Syntactic analysis (parsing): Tokens -&gt; Syntax tree
• Semantic analysis (mainly, type checking)</p>
<h2 id="intermediate-representation" tabindex="-1">Intermediate Representation</h2>
<p>• Internal compiler language that is:
○ Language-independent
○ Machine-independent
○ Easy to optimize
• Why yet another language?
○ Assembly does not have enough info to optimize it well
○ Enables modularity and reuse</p>
<p><img src="assets/2022-11-21-15-53-03.png" alt=""></p>
<h3 id="data-flow-graph-(dfg)" tabindex="-1">Data flow graph (DFG)</h3>
<p>▪ Represents flow of data inside “basic block”
▪ Basic blocks
– Code with one entry one exit
– May have a branch at the end, not before
▪ Does not represent control.
▪ Describes the minimal ordering requirements on operations.
▪ Static Single Assignment is employed to ease optimizations</p>
<h3 id="static-single-assignment-(ssa)" tabindex="-1">Static Single Assignment (SSA)</h3>
<p>▪ If a variable is assigned more that once in the source code:
– SSA keeps only the first assignment
– The rest of the assignments are renamed to temporary variables</p>
<p><img src="assets/2022-11-21-15-57-42.png" alt=""></p>
<h3 id="dfg-and-partial-orders" tabindex="-1">DFG and Partial Orders</h3>
<p><img src="assets/2022-11-21-15-58-56.png" alt=""></p>
<h2 id="optimizations" tabindex="-1">Optimizations</h2>
<h3 id="control-data-flow-graph-(cdfg)" tabindex="-1">Control-Data Flow Graph (CDFG)</h3>
<p>▪ Represents control and data flow
– Nodes: basic blocks
– Edges: branches between basic blocks</p>
<p><img src="assets/2022-11-21-16-01-05.png" alt="">
<img src="assets/2022-11-21-16-01-35.png" alt=""></p>
<h3 id="ir-optimization" tabindex="-1">IR Optimization</h3>
<p>▪ Machine independent optimizations
– Code optimizations independent of the target architecture
– e.g. dead code elimination, constant propagation, constant folding etc.
▪ Machine dependent optimizations
– Specifically aim at target architecture
– May not be applicable directly across different architectures
– e.g. Instruction selection, register allocation etc.
▪ Perform a set of passes over the CFG
– Each pass does a specific, simple task over the CFG
– By repeating multiple simple passes on the CFG over and over, compilers achieve very complex optimizations
▪ Example optimizations:
– Dead code elimination: Eliminate assignments to variables that are never used, or basic blocks that are never reached
– Constant propagation: Identify variables that are constant, substitute the constant elsewhere
– Constant folding: Compute and substitute constant expressions</p>
<h2 id="code-generation" tabindex="-1">Code Generation</h2>
<p>▪ Translate optimized IR to assembly
▪ Register allocation: Map variable to registers
– If #variables &gt; #registers, map some to memory and load/store when needed
▪ Translate each assignment to instruction
– Some assignments may require more than one instruction if ISA does not have operations
▪ Emit each basic block: labels, assignments and branches
▪ Lay out basic blocks, remove superfluous branches
▪ ISA and CPU specific optimization
– E.g. reorder instructions if possible</p>
<h2 id="loop-transformations" tabindex="-1">Loop Transformations</h2>
<h2 id="register-allocation" tabindex="-1">Register Allocation</h2>

      </article>
      </div>
  </body>
</html>
