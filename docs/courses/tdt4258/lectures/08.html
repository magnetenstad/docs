<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>08.md</title>
    <link rel="icon" type="image/x-icon" href="../../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col links">
        
<p><h4><a href="../index.html">tdt4258/</a><a href="./index.html">lectures</a>
</h4></p>
<ul>
<li>ğŸ“‚ <a href="./assets/index.html">assets</a></li>
<li>ğŸ“„ <a href="01.html">01</a></li>
<li>ğŸ“„ <a href="02.html">02</a></li>
<li>ğŸ“„ <a href="03.html">03</a></li>
<li>ğŸ“„ <a href="04.html">04</a></li>
<li>ğŸ“„ <a href="05.html">05</a></li>
<li>ğŸ“„ <a href="06.html">06</a></li>
<li>ğŸ“„ <a href="07.html">07</a></li>
<li>ğŸ“„ <a href="08.html">08 âœ¨</a></li>
<li>ğŸ“„ <a href="09.html">09</a></li>
<li>ğŸ“„ <a href="10.html">10</a></li>
<li>ğŸ“„ <a href="11.html">11</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#compilation-and-optimizations">Compilation and Optimizations</a><ol><li><a href="#intro-to-compilers">Intro to Compilers</a><ol><li><a href="#overview">Overview</a></li><li><a href="#declaration-vs-definition">Declaration vs Definition</a></li></ol></li><li><a href="#compilers-frontend">Compilers Frontend</a><ol><li><a href="#compilers">Compilers</a></li><li><a href="#detailed-compilation-flow">Detailed Compilation Flow</a></li><li><a href="#the-c-pre-processor">The C pre-processor</a></li><li><a href="#anatomy-of-a-modern-compiler">Anatomy of a Modern Compiler</a><ol><li><a href="#frontend-(analysis)">Frontend (analysis)</a></li><li><a href="#back-end-(synthesis)">Back-end (synthesis)</a></li></ol></li><li><a href="#frontend-stages">Frontend Stages</a></li></ol></li><li><a href="#intermediate-representation">Intermediate Representation</a><ol><li><a href="#data-flow-graph-(dfg)">Data flow graph (DFG)</a></li><li><a href="#static-single-assignment-(ssa)">Static Single Assignment (SSA)</a></li><li><a href="#dfg-and-partial-orders">DFG and Partial Orders</a></li></ol></li><li><a href="#optimizations">Optimizations</a><ol><li><a href="#control-data-flow-graph-(cdfg)">Control-Data Flow Graph (CDFG)</a></li><li><a href="#ir-optimization">IR Optimization</a></li></ol></li><li><a href="#code-generation">Code Generation</a></li><li><a href="#summary%3A-modern-compilers">Summary: Modern Compilers</a></li><li><a href="#loop-transformations">Loop Transformations</a><ol><li><a href="#%231%3A-loop-unrolling">#1: Loop Unrolling</a></li><li><a href="#%232%3A-loop-fusion">#2: Loop Fusion</a></li><li><a href="#%233%3A-loop-distribution%2Ffission">#3: Loop Distribution/Fission</a></li><li><a href="#%234%3A-loop-interchange">#4: Loop Interchange</a></li><li><a href="#%235%3A-loop-tiling">#5: Loop Tiling</a></li></ol></li><li><a href="#function-inlining-and-register-allocation">Function Inlining and Register Allocation</a><ol><li><a href="#procedure%2Ffunction-inlining">Procedure/Function Inlining</a></li><li><a href="#register-allocation">Register Allocation</a></li><li><a href="#register-allocation-with-graph-coloring">Register Allocation with Graph Coloring</a></li><li><a href="#instruction-selection">Instruction Selection</a></li></ol></li><li><a href="#assembler-and-linker">Assembler and linker</a><ol><li><a href="#symbol-table">Symbol Table</a></li><li><a href="#object-file">Object File</a></li><li><a href="#linker">Linker</a><ol><li><a href="#dynamic-linking">Dynamic Linking</a></li></ol></li></ol></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="compilation-and-optimizations" tabindex="-1">Compilation and Optimizations</h1>
<ul>
<li>Chapter 5 (5.1 - 5.7)</li>
</ul>
<h2 id="intro-to-compilers" tabindex="-1">Intro to Compilers</h2>
<h3 id="overview" tabindex="-1">Overview</h3>
<p>â–ª Programs are divided into compilation units
â€“ Provide degree of modularity
â€“ Each commonly has main file (.c) for source code
â€“ Header files (.h) declare public interfaces of units
â–ª Each unit is compiled separately to relocatable object code
â€“ Allows creation of object-code libraries
â–ª A linker combines these into an executable, resolving references between units
â–ª A loader sets up the executable program in memory and initialises data areas, prior to the program being run</p>
<h3 id="declaration-vs-definition" tabindex="-1">Declaration vs Definition</h3>
<p>â–ª Declaration: inform the compiler of the existence of a
variable or function</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>; <span class="hljs-comment">// in .h file</span>
</code></pre>
<p>â–ª Definition: provide function body; allocate memory for
local variables</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> { <span class="hljs-comment">// in .c file</span>
 <span class="hljs-type">int</span> temp = *a;
 *a = *b;
 *b = temp;
}
</code></pre>
<h2 id="compilers-frontend" tabindex="-1">Compilers Frontend</h2>
<h3 id="compilers" tabindex="-1">Compilers</h3>
<p>â€¢ Bare minimum for a functional compiler</p>
<p><img src="assets/2022-11-21-15-36-16.png" alt=""></p>
<p>â€¢ Good compilers
o Produce meaningful errors on incorrect programs
o Produce fast, optimized code</p>
<h3 id="detailed-compilation-flow" tabindex="-1">Detailed Compilation Flow</h3>
<p><img src="assets/2022-11-21-15-37-03.png" alt=""></p>
<h3 id="the-c-pre-processor" tabindex="-1">The C pre-processor</h3>
<p>â–ª Includes â€“ imports header files</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>â–ª Text substitution, e.g. define constants</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME value</span>
</code></pre>
<p>â–ª Macros (inline functions)</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(X,Y) (X&gt;Y ? X : Y) <span class="hljs-comment">// careful with macros!</span></span>
</code></pre>
<p>â–ª Conditional compilation</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Debugging message"</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">// $ gcc -DDEBUG</span>
</code></pre>
<p>â–ª Inserts header files to C source code file in response to</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"A.h"</span></span>
</code></pre>
<p>â–ª Performs macro substitution
â€“ E.g. In response to <code><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">CONST</span> <span class="hljs-number">5</span></span></code>
â€“ All references to CONST in source will be replaced by 5
â–ª No type checking or anything, just a direct textual replacement
â–ª To examine the output gcc pre-processor <code><span class="hljs-symbol">$</span> gcc â€“E <span class="hljs-keyword">file</span>.c â€“o output.c</code></p>
<h3 id="anatomy-of-a-modern-compiler" tabindex="-1">Anatomy of a Modern Compiler</h3>
<p><img src="assets/2022-11-21-15-45-08.png" alt=""></p>
<h4 id="frontend-(analysis)" tabindex="-1">Frontend (analysis)</h4>
<p>â€¢ Read source program
â€¢ Break it up into basic elements
â€¢ Check correctness, report errors
â€¢ Translate to generic intermediate representation (IR)</p>
<h4 id="back-end-(synthesis)" tabindex="-1">Back-end (synthesis)</h4>
<p>â€¢ Optimize IR
â€¢ Translate IR to ASM
â€¢ Optimize ASM</p>
<h3 id="frontend-stages" tabindex="-1">Frontend Stages</h3>
<p>â€¢ Lexical analysis (scanning): Source -&gt; List of tokens
â€¢ Syntactic analysis (parsing): Tokens -&gt; Syntax tree
â€¢ Semantic analysis (mainly, type checking)</p>
<h2 id="intermediate-representation" tabindex="-1">Intermediate Representation</h2>
<p>â€¢ Internal compiler language that is:
â—‹ Language-independent
â—‹ Machine-independent
â—‹ Easy to optimize
â€¢ Why yet another language?
â—‹ Assembly does not have enough info to optimize it well
â—‹ Enables modularity and reuse</p>
<p><img src="assets/2022-11-21-15-53-03.png" alt=""></p>
<h3 id="data-flow-graph-(dfg)" tabindex="-1">Data flow graph (DFG)</h3>
<p>â–ª Represents flow of data inside â€œbasic blockâ€
â–ª Basic blocks
â€“ Code with one entry one exit
â€“ May have a branch at the end, not before
â–ª Does not represent control.
â–ª Describes the minimal ordering requirements on operations.
â–ª Static Single Assignment is employed to ease optimizations</p>
<h3 id="static-single-assignment-(ssa)" tabindex="-1">Static Single Assignment (SSA)</h3>
<p>â–ª If a variable is assigned more that once in the source code:
â€“ SSA keeps only the first assignment
â€“ The rest of the assignments are renamed to temporary variables</p>
<p><img src="assets/2022-11-21-15-57-42.png" alt=""></p>
<h3 id="dfg-and-partial-orders" tabindex="-1">DFG and Partial Orders</h3>
<p><img src="assets/2022-11-21-15-58-56.png" alt=""></p>
<h2 id="optimizations" tabindex="-1">Optimizations</h2>
<h3 id="control-data-flow-graph-(cdfg)" tabindex="-1">Control-Data Flow Graph (CDFG)</h3>
<p>â–ª Represents control and data flow
â€“ Nodes: basic blocks
â€“ Edges: branches between basic blocks</p>
<p><img src="assets/2022-11-21-16-01-05.png" alt="">
<img src="assets/2022-11-21-16-01-35.png" alt=""></p>
<h3 id="ir-optimization" tabindex="-1">IR Optimization</h3>
<p>â–ª Machine independent optimizations
â€“ Code optimizations independent of the target architecture
â€“ e.g. dead code elimination, constant propagation, constant folding etc.
â–ª Machine dependent optimizations
â€“ Specifically aim at target architecture
â€“ May not be applicable directly across different architectures
â€“ e.g. Instruction selection, register allocation etc.
â–ª Perform a set of passes over the CFG
â€“ Each pass does a specific, simple task over the CFG
â€“ By repeating multiple simple passes on the CFG over and over, compilers achieve very complex optimizations
â–ª Example optimizations:
â€“ Dead code elimination: Eliminate assignments to variables that are never used, or basic blocks that are never reached
â€“ Constant propagation: Identify variables that are constant, substitute the constant elsewhere
â€“ Constant folding: Compute and substitute constant expressions</p>
<h2 id="code-generation" tabindex="-1">Code Generation</h2>
<p>â–ª Translate optimized IR to assembly
â–ª Register allocation: Map variable to registers
â€“ If #variables &gt; #registers, map some to memory and load/store when needed
â–ª Translate each assignment to instruction
â€“ Some assignments may require more than one instruction if ISA does not have operations
â–ª Emit each basic block: labels, assignments and branches
â–ª Lay out basic blocks, remove superfluous branches
â–ª ISA and CPU specific optimization
â€“ E.g. reorder instructions if possible</p>
<h2 id="summary%3A-modern-compilers" tabindex="-1">Summary: Modern Compilers</h2>
<p><img src="assets/2022-11-25-11-04-21.png" alt=""></p>
<h2 id="loop-transformations" tabindex="-1">Loop Transformations</h2>
<p>â–ª Why is it important
â€“ Programs spends lots of time in loops
â–ª Goal
â€“ Reduce loop overhead
â€“ Increase opportunities for other optimizations
â€“ Improve pipeline and memory system performance</p>
<h3 id="%231%3A-loop-unrolling" tabindex="-1">#1: Loop Unrolling</h3>
<p>â–ª Duplicates loop body â€˜nâ€™ times and adjust loop bounds
â€“ Reduces number of comparisons/branches to test loop exit
â€¢ Branches are big performance bottleneck in hardware
â€“ Increases loop body size
â€¢ Enables more optimizations
â€¢ More register pressure</p>
<p><img src="assets/2022-11-25-11-12-20.png" alt=""></p>
<h3 id="%232%3A-loop-fusion" tabindex="-1">#2: Loop Fusion</h3>
<p>â–ª Combines two (or more) loops into one</p>
<ul>
<li>Pros:
<ul>
<li>May improve data locality</li>
<li>Reduces loop overhead</li>
<li>May enable better instruction scheduling</li>
</ul>
</li>
<li>Cons:
<ul>
<li>May hurt data locality</li>
<li>May hurt I-cache hit rate</li>
</ul>
</li>
</ul>
<p><img src="assets/2022-11-25-11-12-33.png" alt=""></p>
<h3 id="%233%3A-loop-distribution%2Ffission" tabindex="-1">#3: Loop Distribution/Fission</h3>
<p>â–ª Divides a loop into two (or more) loops</p>
<ul>
<li>Pros:
<ul>
<li>Enables optimizations: 2nd loop is parallel loop</li>
<li>Reduces register pressure</li>
</ul>
</li>
<li>Cons:
<ul>
<li>Increases loop overhead</li>
</ul>
</li>
</ul>
<p><img src="assets/2022-11-25-11-12-42.png" alt=""></p>
<h3 id="%234%3A-loop-interchange" tabindex="-1">#4: Loop Interchange</h3>
<p>â–ª Switches the order of loops in a loop nest
â–ª Can improve data locality and parallelism</p>
<p><img src="assets/2022-11-25-11-12-50.png" alt=""></p>
<h3 id="%235%3A-loop-tiling" tabindex="-1">#5: Loop Tiling</h3>
<p>â–ª Breaks a loop into a set of nested loops
â€“ Each inner loop operates on a subset of data
â–ª Changes memory access pattern: Can improve locality</p>
<p><img src="assets/2022-11-25-11-13-47.png" alt=""></p>
<h2 id="function-inlining-and-register-allocation" tabindex="-1">Function Inlining and Register Allocation</h2>
<h3 id="procedure%2Ffunction-inlining" tabindex="-1">Procedure/Function Inlining</h3>
<p>â–ª Replaces call with the body of the callee (called function)
â–ª Programmer can ask compiler to inline a function
â€“ C provides inline keyword
â–ª Compiler itself can inline a function if deemed beneficial</p>
<p><img src="assets/2022-11-25-11-17-33.png" alt=""></p>
<p>â–ª Function calls can be costly
â€“ Direct costs: arguments and results passing, call/return (branch) instructions, stack frame maintenance etc
â€“ Indirect costs: breaks intra-procedural analysis to inter-procedural analysis (which is more complex)
â–ª Inlining removes these costs
â–ª Downside
â€“ Can increases code size
â€“ Can reduce instruction cache hit rate</p>
<h3 id="register-allocation" tabindex="-1">Register Allocation</h3>
<p>â–ª Registers temporarily hold variables
â–ª Aim: Allocate registers to variables such that memory accesses are minimized
â€“ Good register allocation is key to performance as memory accesses can be costly (imagine cache misses)
â–ª Compilers analyze lifetime of variables for register allocation
â–ª Programmers could hint which variables to keep in registers
â€“ C supports register keyword
â€“ Modern compilers just ignore it!
â–ª Some variables always need to be in memory
â€“ volatile keyword provides this functionality
â€“ Still brought to a register for using the value</p>
<h3 id="register-allocation-with-graph-coloring" tabindex="-1">Register Allocation with Graph Coloring</h3>
<p>â–ª Edges between variable that are live at the same time
â–ª Represent each register with a color
â–ª Color the nodes with as few colors as possible
â€“ No edge must share a color
â–ª NP-complete
â€“ Compilers use heuristics to reach a good solution</p>
<h3 id="instruction-selection" tabindex="-1">Instruction Selection</h3>
<p>â–ª IR code can be translated to a number instruction
sequences depending types of instructions in ISA
â–ª IR expressions are represented as graphs (CDFG)
â€“ Find the best template for expression
â€“ The template should minimize the chosen cost metric</p>
<h2 id="assembler-and-linker" tabindex="-1">Assembler and linker</h2>
<p>â–ª Generate machine instructions (binary) from assembly instructions (symbolic)
â€“ One to one translation (usually)
â–ª Translate labels into addresses
â–ª Handle pseudo-ops
â–ª Two pass approach
â€“ First pass: Generate symbol table
â€“ Second pass: resolve labels and generate machine instructions</p>
<h3 id="symbol-table" tabindex="-1">Symbol Table</h3>
<p>â–ª Generating symbol table:
â€“ Scan the file to collect labels and their addresses
â–ª Addresses are generally relative to the first instructions in
the file</p>
<h3 id="object-file" tabindex="-1">Object File</h3>
<p>â–ª Output of assembler
â–ª Several standards
â€“ ELF (Unix), ECOFF (Windows), Mach-O (OS X)
â–ª Object file includes
â€“ Symbol table
â€“ Program code (.text segment)
â€“ Data (.data segment)
â€“ Information about relocatable parts
â€“ Debug data (references to source files)</p>
<h3 id="linker" tabindex="-1">Linker</h3>
<p>â–ª Takes multiple object files and libraries and generates one executable file
â€“ Combines all object file segments (text, data)
â€“ Determines start address for all modules
â€“ Combines all symbol tables
â€“ Resolves all symbols
â–ª Transforms relative address to absolute addresses
â–ª Produces an error if cannot find a label/symbol in merged symbol table</p>
<h4 id="dynamic-linking" tabindex="-1">Dynamic Linking</h4>
<p>â–ª Most operating systems can link modules at load time
â€“ e.g. shared libraries (.so on linux platforms)
â€“ Saves storage space</p>

        <div style="height: 100vh;"></div>
      </article>
      </div>
  </body>
</html>
