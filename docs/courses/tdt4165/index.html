<!DOCTYPE html>
<html>
  <head>
    <!-- Katex -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"/>

    <!-- GitHub Markdown Styles -->
    <link rel="stylesheet" href=
        "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

    <title>index.md</title>
    <link rel="icon" type="image/x-icon" href="../../favicon.png"/>

    <!-- Custom Styles -->
    <link rel="stylesheet" href="../../styles.css">
  
  </head>

  <body class="markdown-body">
    <div class="page flex-row">
      <div class="col links">
        
<p><h4><a href="../index.html">courses/</a><a href="./index.html">tdt4165 ‚ú®</a>
</h4></p>
<ul>
<li>üìÇ <a href="./assets/index.html">assets</a></li>
<li>üìÇ <a href="./lectures/index.html">lectures</a></li>
</ul>
<p><h4>Table of Contents</h4></p>
<nav class="table-of-contents"><ol><li><a href="#%F0%9F%92%AC-tdt4165---programming-languages">üí¨ TDT4165 - Programming Languages</a><ol><li><a href="#links">Links</a></li><li><a href="#0-preface-(p.-i-xxvii)">0 Preface (p. i-xxvii)</a></li><li><a href="#1-introduction-to-programming-concepts-(p.-1-23)">1 Introduction to Programming Concepts (p. 1-23)</a><ol><li><a href="#variables%2C-functions-and-lists">Variables, Functions and Lists</a></li><li><a href="#lazy-evalution-and-concurrency">Lazy Evalution and Concurrency</a></li><li><a href="#explicit-state%2C-objects%2C-classes-and-records">Explicit State, Objects, Classes and Records</a></li><li><a href="#nondeterminism-and-atomicity">Nondeterminism and Atomicity</a></li><li><a href="#computation-model-descriptions">Computation Model Descriptions</a></li></ol></li><li><a href="#2-declarative-computation-model-(p.-29-106)">2 Declarative Computation Model (p. 29-106)</a><ol><li><a href="#2.1-defining-practical-programming-languages">2.1 Defining Practical Programming Languages</a></li><li><a href="#2.2-the-single-assignment-store">2.2 The single-assignment store</a></li><li><a href="#2.3-kernel-language">2.3 Kernel language</a></li><li><a href="#2.4-kernel-language-semantics">2.4 Kernel language semantics</a></li><li><a href="#2.5-memory-management">2.5 Memory management</a></li><li><a href="#2.6-from-kernel-language-to-practical-language">2.6 From kernel language to practical language</a></li><li><a href="#2.7-exceptions">2.7 Exceptions</a></li><li><a href="#2.8-advanced-topics">2.8 Advanced topics</a></li></ol></li><li><a href="#3-declarative-programming-techniques-(p.-111-230)">3 Declarative Programming Techniques (p. 111-230)</a><ol><li><a href="#3.1-what-is-declarativeness%3F">3.1 What is declarativeness?</a></li><li><a href="#3.2-iterative-computation">3.2 Iterative computation</a></li><li><a href="#3.3-recursive-computiation">3.3 Recursive computiation</a></li><li><a href="#3.4-programming-with-recursion">3.4 Programming with recursion</a><ol><li><a href="#3.4.2.4-converting-recursive-to-iterative-computations">3.4.2.4 Converting recursive to iterative computations</a></li><li><a href="#3.4.2.5-correctness-with-state-invariants">3.4.2.5 Correctness with state invariants</a></li></ol></li><li><a href="#3.5-time-and-space-efficiency">3.5 Time and space efficiency</a></li><li><a href="#3.6-higher-order-programming">3.6 Higher-order programming</a></li><li><a href="#3.7-abstract-data-types">3.7 Abstract data types</a></li><li><a href="#3.8-nondeclarative-needs">3.8 Nondeclarative needs</a></li><li><a href="#3.9-program-design-in-the-small">3.9 Program design in the small</a></li></ol></li><li><a href="#4-declarative-concurrency-(4.1-4.5)-(p.-233-304)">4 Declarative Concurrency (4.1-4.5) (p. 233-304)</a><ol><li><a href="#4.1-the-data-driven-concurrent-model">4.1 The data-driven concurrent model</a></li><li><a href="#4.2-basic-thread-programming">4.2 Basic thread programming</a></li><li><a href="#4.3-streams">4.3 Streams</a></li><li><a href="#4.4-using-the-declarative-concurrent-model-directly">4.4 Using the declarative concurrent model directly</a></li><li><a href="#4.5-lazy-execution">4.5 Lazy execution</a></li></ol></li><li><a href="#9-relational-programming-(9.1-9.3%2C-9.7)-(p.-621-641%2C-660-671)">9 Relational Programming (9.1-9.3, 9.7) (p. 621-641, 660-671)</a><ol><li><a href="#9.1-the-relational-computation-model">9.1 The relational computation model</a></li><li><a href="#9.2-further-examples">9.2 Further examples</a></li><li><a href="#9.3-relation-to-logic-programming">9.3 Relation to logic programming</a></li><li><a href="#9.7-the-prolog-language">9.7 The Prolog language</a></li></ol></li><li><a href="#12-constraint-programming-(p.-749-773)">12 Constraint Programming (p. 749-773)</a><ol><li><a href="#12.1-propagate-and-search">12.1 Propagate-and-search</a></li><li><a href="#12.2-programming-techniques">12.2 Programming techniques</a></li><li><a href="#12.3-the-constraint-based-computational-model">12.3 The constraint-based computational model</a></li><li><a href="#12.4-defining-and-using-computation-spaces">12.4 Defining and using computation spaces</a></li><li><a href="#12.5-implementing-the-relational-computation-model">12.5 Implementing the relational computation model</a></li></ol></li></ol></li></ol></nav>
      </div>
      <article class="col content">
        
<h1 id="%F0%9F%92%AC-tdt4165---programming-languages" tabindex="-1">üí¨ TDT4165 - Programming Languages</h1>
<p>371 pages.</p>
<h2 id="links" tabindex="-1">Links</h2>
<ul>
<li><a href="https://www.ntnu.no/studier/emner/TDT4165/2022#tab=omEmnet">NTNU</a></li>
<li><a href="https://www.wikipendium.no/TDT4165_Programmeringsspr%C3%A5k/nb/">Wikipendium</a></li>
<li><a href="http://mozart2.org/mozart-v1/doc-1.4.0/tutorial/index.html">Oz Documentation</a></li>
<li><a href="https://strasheela.sourceforge.net/strasheela/doc/Basics-2.html">Oz Basics</a></li>
<li><a href="http://rigaux.org/language-study/syntax-across-languages-per-language/Oz.html">Oz Syntax</a></li>
</ul>
<h2 id="0-preface-(p.-i-xxvii)" tabindex="-1">0 Preface (p. i-xxvii)</h2>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computation model</td>
<td>A formal system that defines how computations are done. (Data types, operations, and a programming language)</td>
</tr>
<tr>
<td>Programming model</td>
<td>What the programmer needs: the programming techniques and design principles made possible by the computation model.</td>
</tr>
<tr>
<td>Kernel language</td>
<td>A simple core language of a computation model</td>
</tr>
<tr>
<td>Creative extension principle</td>
<td>A new concept is added when programs become complicated for technical reasons unrelated to the problem being solved</td>
</tr>
<tr>
<td>Programming</td>
<td>The act of extending or changing a system‚Äôs functionality</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Computation model</th>
<th>Languages</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object-oriented</td>
<td>Java, Smalltalk</td>
</tr>
<tr>
<td>Functional</td>
<td>Haskell, Standard ML</td>
</tr>
<tr>
<td>Logic</td>
<td>Prolog, Mercury</td>
</tr>
<tr>
<td>Concurrent</td>
<td>Erlang</td>
</tr>
</tbody>
</table>
<p>In the <strong>kernel language approach</strong>, a practical language is translated into a kernel language that consists of a small number of programmer-significant elements. The rich set of abstractions and syntax is encoded in the kernel language, giving insight into what the language does. Simple formal semantics allow reasoning about program correctness and complexity. This is a language-independent way to study programming.</p>
<h2 id="1-introduction-to-programming-concepts-(p.-1-23)" tabindex="-1">1 Introduction to Programming Concepts (p. 1-23)</h2>
<h3 id="variables%2C-functions-and-lists" tabindex="-1">Variables, Functions and Lists</h3>
<p>The <strong>declare</strong> statement creates a new store variable and makes the variable identifier refer to it. There are two concepts hiding behind the word ‚Äúvariable‚Äù:</p>
<ul>
<li>The identifier.</li>
<li>The store variable.</li>
</ul>
<p>The fun statement defines a <strong>function</strong>. The variable Fact is bound to the function. The function has one argument N, which is a local variable.</p>
<pre><code class="hljs language-oz">declare
fun {Fact N}
  if N==0 then 1 else N*{Fact N-1} end
end
</code></pre>
<p>A <strong>list</strong> <code><span class="hljs-string">[1 2 3]</span></code> is a chain of links <code>HEAD<span class="hljs-string">|TAIL</span></code>, where each link contains two things: one list element and a reference to the rest of the chain <code><span class="hljs-attribute">L</span> = <span class="hljs-number">1</span>|[<span class="hljs-number">2</span> <span class="hljs-number">3</span>]</code>. Here, <code><span class="hljs-attribute">L</span>.<span class="hljs-number">1</span></code> is <code>1</code> and <code><span class="hljs-attribute">L</span>.<span class="hljs-number">2</span></code> is <code><span class="hljs-string">[2 3]</span></code>. The empty list is <code><span class="hljs-literal">nil</span></code>. A list of one item is <code><span class="hljs-number">1</span><span class="hljs-string">|nil</span></code>.</p>
<pre><code class="hljs language-oz">declare
L = [5 6 7 8]
case L of H|T then {Browse H} {Browse T} end
</code></pre>
<p>In the preceding code, the <code><span class="hljs-keyword">case</span></code> instruction does <strong>pattern matching</strong>.</p>
<h3 id="lazy-evalution-and-concurrency" tabindex="-1">Lazy Evalution and Concurrency</h3>
<p>In <strong>lazy evaluation</strong>, a calculation is done only when the result is needed (opposed to standard, eager evaluation). This enables calculation with seemingly infinite data structures without any loop boundary
conditions.</p>
<pre><code class="hljs language-oz">fun lazy {Ints N}
  N|{Ints N+1}
end
</code></pre>
<p>The ability to pass functions as arguments and return values is known as <strong>higher-order programming</strong>.</p>
<p>A <strong>concurrent</strong> program has several independent activities, each of which executes at its own pace. We introduce concurrency by creating threads with the <code>thread</code> instruction. Thread execution is <strong>interleaved</strong>.That is, threads take turns each executing a little.</p>
<p>With <strong>dataflow</strong> behavior, an operation that tries to use a variable that is not yet bound will wait for it to be bound. Two nice properties of dataflow are (1) calculations work correctly independent of how they are partitioned between threads. (2) calculations are
patient: they do not signal errors, but simply wait.</p>
<h3 id="explicit-state%2C-objects%2C-classes-and-records" tabindex="-1">Explicit State, Objects, Classes and Records</h3>
<p><strong>Explicit state</strong> may be achieved with <strong>memory cells</strong>:</p>
<pre><code class="hljs language-oz">declare
C = {NewCell 0}
C := @C+1
{Browse @C}
</code></pre>
<p>This further enables <strong>objects</strong>. In the following, the cell is referenced by a local variable, i.e. it is <strong>encapsulated</strong>.</p>
<pre><code class="hljs language-oz">declare
local C in
  C = {NewCell 0}
  fun {Bump}
    C := @C+1
    @C
  end
  fun {Read}
    @C
  end
end
</code></pre>
<p>As long as the interface to the counter object is the same, the user program does not need to know the implementation. The separation of interface and implementation is the essence of <strong>data abstraction</strong>. A program that uses a counter will work correctly for any implementation as long as the interface is the same. This property is called <strong>polymorphism</strong>.</p>
<p>To instantiate multiple objects, we may create an object factory, i.e. a <strong>class</strong>.</p>
<pre><code class="hljs language-oz">declare
fun {NewCounter} C Bump Read in
  C = {NewCell 0}
  fun {Bump}
    C:=@C+1
    @C
  end
    fun {Read}
    @C
  end
  counter(bump:Bump read:Read)
end
</code></pre>
<p>The Bump and Read functions are grouped together into a <strong>record</strong>, a compound data structure that allows easy access to its parts. The record <code>counter(<span class="hljs-name">bump</span><span class="hljs-symbol">:Bump</span> read<span class="hljs-symbol">:Read</span>)</code> is characterized by its label counter and by its two fields, called bump and read. These are accessible with the <code>.</code> (dot) operator.</p>
<p>Programming with classes and objects is called <strong>object-based programming</strong>. Adding one new idea, <strong>inheritance</strong>, to object-based programming gives <strong>object-oriented programming</strong>.</p>
<h3 id="nondeterminism-and-atomicity" tabindex="-1">Nondeterminism and Atomicity</h3>
<p>With <em>both</em> concurrency and state, we introduce <strong>nondeterminism</strong>. An observable nondeterminism is sometimes called a <strong>race condition</strong>. Programming with concurrency and state together is largely a question of mastering the interleavings.</p>
<p>An operation is <strong>atomic</strong> if no intermediate states can be observed. A <strong>lock</strong> has the property that only one thread at a time can be executing inside.If a second thread tries to get in, then it will wait until the first gets out. Therefore what happens inside the lock is atomic.</p>
<h3 id="computation-model-descriptions" tabindex="-1">Computation Model Descriptions</h3>
<table>
<thead>
<tr>
<th>Computation model</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Declarative model</td>
<td>Declarative programs define mathematical functions.They are the easiest to reason about and to test.</td>
</tr>
<tr>
<td>Concurrent declarative model</td>
<td>Adding dataflow concurrency gives a model that is still declarative but that allows a more flexible, incremental execution.</td>
</tr>
<tr>
<td>Lazy declarative model</td>
<td>Adding laziness allows calculating with potentially infinite data structures.This is good for resource management and program structure.</td>
</tr>
<tr>
<td>Stateful model</td>
<td>Adding explicit state allows writing programs whose behavior changes over time.This is good for program modularity.</td>
</tr>
<tr>
<td>Object-oriented model</td>
<td>Object-oriented programming is a programming style for stateful programming with data abstractions. Enables powerful techniques such as polymorphism and inheritance.</td>
</tr>
<tr>
<td>Shared-state concurrent model</td>
<td>Gives the advantages of both the stateful and concurrent models, but should be programmed carefully.</td>
</tr>
</tbody>
</table>
<h2 id="2-declarative-computation-model-(p.-29-106)" tabindex="-1">2 Declarative Computation Model (p. 29-106)</h2>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Declarative programming</td>
<td>Evaluating functions over partial data structures (stateless programming)</td>
</tr>
</tbody>
</table>
<h3 id="2.1-defining-practical-programming-languages" tabindex="-1">2.1 Defining Practical Programming Languages</h3>
<p><img src="assets/2022-11-25-13-28-01.png" alt=""></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Grammar</td>
<td>A set of rules that defines how to make ‚Äòsentences‚Äô (or <em>statements</em>) out of ‚Äòwords‚Äô (or <em>tokens</em>).</td>
</tr>
<tr>
<td>Tokenizer / Lexical analyzer</td>
<td>A program that accepts a sequence of characters and returns a sequence of tokens</td>
</tr>
<tr>
<td>Parser</td>
<td>A program that accepts a sequence of tokens and returns a parse tree</td>
</tr>
</tbody>
</table>
<p>A <strong>terminal</strong> symbol is simply a token. A <strong>nonterminal</strong> symbol represents a sequence of tokens.</p>
<p>Context-free grammars can be <strong>ambiguous</strong>, i.e., there can be several parse trees that correspond to a given token sequence. The usual approach is to add two conditions, <em>precedence</em> and <em>associativity</em>.</p>
<p>The <strong>semantics</strong> of a language defines what a program does when it executes.
There are four widely used approaches to language semantics: (1) operational, in terms of an abstract machine, (2) axiomatic, a relation between input and output, (3) denotational, functions over an abstract domain, (4) logical, model of a logical theory.</p>
<p><img src="assets/2022-12-15-14-25-07.png" alt=""></p>
<p>There are two phases to defining a <strong>linguistic abstraction</strong>. First, define a new grammatical construct.Second, define its translation into the kernel language.</p>
<p><strong>Syntactic sugar</strong> does not provide a new abstraction, but just reduces program size and improves program readability.</p>
<h3 id="2.2-the-single-assignment-store" tabindex="-1">2.2 The single-assignment store</h3>
<p>Variables in the single-assignment store are called declarative variables (or dataflow variables). Once bound, the variable cannot be bound to another value.</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Value store</td>
<td>All variables are bound to values. Single assignment.</td>
</tr>
<tr>
<td>Single-assignment store</td>
<td>Variables are bound to a value or unbound. Single assignment.</td>
</tr>
<tr>
<td>Cell store</td>
<td>Variables may be rebound.</td>
</tr>
<tr>
<td>Variable identifier</td>
<td>The variable names in program source code</td>
</tr>
<tr>
<td>Partial value</td>
<td>A data structure that may contain unbound variables.</td>
</tr>
</tbody>
</table>
<p>In the declarative model, creating a variable and binding it are done separately. What happens if we try to use the variable before it is bound? In Oz, execution waits until the variable is bound and then continues.</p>
<h3 id="2.3-kernel-language" tabindex="-1">2.3 Kernel language</h3>
<p>There are two basic approaches to typing, namely dynamic and static typing. In <strong>static typing</strong>, all variable types are known at compile time. In <em>dynamic typing</em>, the variable type is known only when the variable is bound. The declarative model is dynamically typed.</p>
<p>Basic types are numbers, atoms, booleans, records, tuples, lists, strings and procedures.</p>
<h3 id="2.4-kernel-language-semantics" tabindex="-1">2.4 Kernel language semantics</h3>
<p><img src="assets/2022-12-15-15-19-55.png" alt=""></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single-assignment store <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œÉ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">œÉ</span></span></span></span></td>
<td>A set of store variables, potentially with value assignments</td>
</tr>
<tr>
<td>Environment <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></td>
<td>A mapping from variable identifiers to entities in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œÉ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">œÉ</span></span></span></span></td>
</tr>
<tr>
<td>Semantic statement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">‚ü®</mo><mi>s</mi><mo stretchy="false">‚ü©</mo><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\langle s \rangle, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">‚ü®</span><span class="mord mathnormal">s</span><span class="mclose">‚ü©</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
<td>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">‚ü®</mo><mi>s</mi><mo stretchy="false">‚ü©</mo></mrow><annotation encoding="application/x-tex">\langle s \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">‚ü®</span><span class="mord mathnormal">s</span><span class="mclose">‚ü©</span></span></span></span> is a statement and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is an environment</td>
</tr>
<tr>
<td>Execution state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>T</mi><mo separator="true">,</mo><mi>œÉ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ST, \sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">œÉ</span><span class="mclose">)</span></span></span></span></td>
<td>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">ST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is a stack of semantic statements and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œÉ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">œÉ</span></span></span></span> is a SAS</td>
</tr>
<tr>
<td>Computation</td>
<td>A sequence of execution states</td>
</tr>
</tbody>
</table>
<p>A program is simply a statement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">‚ü®</mo><mi>s</mi><mo stretchy="false">‚ü©</mo></mrow><annotation encoding="application/x-tex">\langle s \rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">‚ü®</span><span class="mord mathnormal">s</span><span class="mclose">‚ü©</span></span></span></span>. The initial execution state is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mo stretchy="false">‚ü®</mo><mi>s</mi><mo stretchy="false">‚ü©</mo><mo separator="true">,</mo><mi mathvariant="normal">‚àÖ</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi mathvariant="normal">‚àÖ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">([\langle s \rangle, \emptyset], \emptyset)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">[</span><span class="mopen">‚ü®</span><span class="mord mathnormal">s</span><span class="mclose">‚ü©</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">‚àÖ</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">‚àÖ</span><span class="mclose">)</span></span></span></span> At each step, the first element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">ST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is popped and execution proceeds according to the form of the element. A semantic stack <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">ST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> can be in one of three run-time states: runnable (can do a computation step), terminated (empty), or suspended (not empty, but it cannot do any computation step).</p>
<p>Suspendable statements have an <em>activation condition</em>. They wait for unbound variable identifiers to be bound.</p>
<h3 id="2.5-memory-management" tabindex="-1">2.5 Memory management</h3>
<p>Consider a recursive procedure with just one recursive call which happens to be the last call in the procedure body.We call such a procedure tail-recursive. We will show that the abstract machine executes a tail-recursive procedure with a constant stack size.This property is called last call optimization or tail call optimization.</p>
<p>The semantic stack and the reachable part of the store are together called the active memory.</p>
<p>Without garbage collection (GC) There are two kinds of program error that can occur:</p>
<ul>
<li>Dangling reference. This happens when a block is reclaimed even though it is still reachable.The system will eventually reuse this block.This means that data structures will be corrupted in unpredictable ways, causing the program to crash.</li>
<li>Memory leak. This happens when a block is not reclaimed even though it is unreachable.The effect is that active memory size keeps growing indefinitely until eventually the system‚Äôs memory resources are exhausted.</li>
</ul>
<h3 id="2.6-from-kernel-language-to-practical-language" tabindex="-1">2.6 From kernel language to practical language</h3>
<h3 id="2.7-exceptions" tabindex="-1">2.7 Exceptions</h3>
<p><img src="assets/2022-12-15-17-58-41.png" alt=""></p>
<h3 id="2.8-advanced-topics" tabindex="-1">2.8 Advanced topics</h3>
<h2 id="3-declarative-programming-techniques-(p.-111-230)" tabindex="-1">3 Declarative Programming Techniques (p. 111-230)</h2>
<p>A declarative operation is <em>independent</em> (does not depend on any execution state outside of itself), <em>stateless</em> (has no internal execution state that is remembered between calls), and <em>deterministic</em> (always gives the same results when given the same arguments).</p>
<p><img src="assets/2022-12-15-20-53-23.png" alt=""></p>
<h3 id="3.1-what-is-declarativeness%3F" tabindex="-1">3.1 What is declarativeness?</h3>
<p>Intuitively, it is programming by defining the what (the results we want to achieve) without explaining the how (the algorithms, etc., needed to achieve the results).</p>
<p>Given any statement in the declarative model, partition the free variable identifiers in the statement into inputs and outputs. Then, given any binding of the input identifiers to partial values and the output identifiers to unbound variables, executing the statement will give one of three results: (1) some binding of the output variables, (2) suspension, or (3) an exception. If the statement is declarative, then for the
same bindings of the inputs, the result is always the same.</p>
<h3 id="3.2-iterative-computation" tabindex="-1">3.2 Iterative computation</h3>
<h3 id="3.3-recursive-computiation" tabindex="-1">3.3 Recursive computiation</h3>
<h3 id="3.4-programming-with-recursion" tabindex="-1">3.4 Programming with recursion</h3>
<h4 id="3.4.2.4-converting-recursive-to-iterative-computations" tabindex="-1">3.4.2.4 Converting recursive to iterative computations</h4>
<p>This may be done by providing some state to the next recursive call, instead of doing the computation after the recursive call.</p>
<h4 id="3.4.2.5-correctness-with-state-invariants" tabindex="-1">3.4.2.5 Correctness with state invariants</h4>
<p>Induction.</p>
<h3 id="3.5-time-and-space-efficiency" tabindex="-1">3.5 Time and space efficiency</h3>
<h3 id="3.6-higher-order-programming" tabindex="-1">3.6 Higher-order programming</h3>
<p>There are four basic operations that underlie all the techniques of higher-order programming:</p>
<ol>
<li>Procedural abstraction: the ability to convert any statement into a procedure value.</li>
<li>Genericity: the ability to pass procedure values as arguments to a procedure call.</li>
<li>Instantiation: the ability to return procedure values as results from a procedure call.</li>
<li>Embedding: the ability to put procedure values in data structures.</li>
</ol>
<p>ForAcc and ForAllAcc are the workhorses of the declarative model.They are both defined with a variable Mid that is used to pass the current state of the accumulator to the rest of the loop.</p>
<p>FoldL and FoldR, which folds from the left and right respectively, are accumulators.</p>
<h3 id="3.7-abstract-data-types" tabindex="-1">3.7 Abstract data types</h3>
<h3 id="3.8-nondeclarative-needs" tabindex="-1">3.8 Nondeclarative needs</h3>
<h3 id="3.9-program-design-in-the-small" tabindex="-1">3.9 Program design in the small</h3>
<h2 id="4-declarative-concurrency-(4.1-4.5)-(p.-233-304)" tabindex="-1">4 Declarative Concurrency (4.1-4.5) (p. 233-304)</h2>
<p>A program in the declarative concurrent model has no observable nondeterminism, if the program does not try to bind the same variable to incompatible values.</p>
<h3 id="4.1-the-data-driven-concurrent-model" tabindex="-1">4.1 The data-driven concurrent model</h3>
<ol>
<li>We add threads and the single instruction <code>thread &lt;s&gt; end</code>. A thread is simply an executing statement, i.e., a semantic stack. This is all we need to start programming with declarative concurrency.</li>
<li>The second step extends the model with another execution order. We add by-need triggers and the single instruction <code>{ByNeed <span class="hljs-keyword">P</span> <span class="hljs-keyword">X</span>}</code>. This adds the possibility to do demand-driven computation, or lazy execution.</li>
</ol>
<p><img src="assets/2022-12-15-23-36-31.png" alt=""></p>
<p><strong>Failure</strong> is an all-or-nothing property: if a declarative concurrent program results in failure for a given set of inputs, then all possible executions with those inputs will result in failure. Often we would like to continue execution instead of terminating, perhaps to repair the error or simply to report it.A natural way to do this is by using exceptions. However, it is important to realize that execution after raising the exception is no longer declarative! If we want execution to become declarative again after a failure, then we have to hide the nondeterminism. This is the responsibility of the programmer.</p>
<p>Each <strong>browser</strong> call is given its own part of the browser window to display its argument. If the argument contains an unbound variable that is bound later, then the display will be <em>updated</em> when the variable is bound. Otherwise, it will display '_'.</p>
<h3 id="4.2-basic-thread-programming" tabindex="-1">4.2 Basic thread programming</h3>
<p>If using concurrency lets your program have a simpler structure, then use it without hesitation.But keep in mind that even though threads are cheap, sequential programs are even cheaper.</p>
<p>For <strong>scheduling</strong>, The Mozart system uses Round Robin with a hardware timer.</p>
<p>Threads are intended for <strong>cooperative concurrency</strong>, not for competitive concurrency. Cooperative concurrency is for entities that are working together on some global goal. On the other hand, competitive concurrency is for entities that have a local goal, managed by the operating system in terms of a concept called a process.</p>
<h3 id="4.3-streams" tabindex="-1">4.3 Streams</h3>
<p>The most useful technique for concurrent programming in the declarative concurrent model is using <strong>streams</strong> to communicate between threads. A stream is a potentially unbounded list of messages, i.e., it is a list whose tail is an unbound dataflow variable. Sending a message is done by extending the stream by one element.</p>
<p><img src="assets/2022-12-16-12-05-51.png" alt="">
<img src="assets/2022-12-16-12-07-36.png" alt=""></p>
<p>We can put a third stream object in between the producer and consumer. We call it a <strong>transducer</strong>. In general, a sequence of stream objects each of which feeds the next is called a pipeline.</p>
<p>The simplest flow control is called demand-driven concurrency, or lazy execution. In this technique, the producer only generates elements when the consumer explicitly demands them. The simplest way to do this is to use dataflow.</p>
<p>But lazy execution also has a serious problem.It leads to a strong reduction in throughput. A <strong>bounded buffer</strong> is a transducer that stores elements up to a maximum number, say n. The producer is allowed to get ahead of the consumer, but only until the buffer is full.</p>
<p>We conclude this discussion by remarking that eager and lazy execution are just extreme cases of a bounded buffer. Execution is eager when the buffer has infinite size. Execution is lazy when the buffer has zero size.</p>
<p><img src="assets/2022-12-16-12-27-33.png" alt=""></p>
<h3 id="4.4-using-the-declarative-concurrent-model-directly" tabindex="-1">4.4 Using the declarative concurrent model directly</h3>
<h3 id="4.5-lazy-execution" tabindex="-1">4.5 Lazy execution</h3>
<p>Lazy functions are not executed when they are called. They do not block either.</p>
<p>To do demand-driven concurrency, we add one instruction, ByNeed, to the kernel language.</p>
<p>The statement <code>{ByNeed <span class="hljs-keyword">P</span> <span class="hljs-keyword">Y</span>}</code> has the same effect as the statement <code>thread {P Y} end</code>, except for scheduling. Both statements call the procedure <code><span class="hljs-selector-tag">P</span></code> in its own thread with argument <code><span class="hljs-attribute">Y</span></code>. The difference between the statements is when the procedure call is executed. For <code>thread {P Y} end</code>, we know that <code>{<span class="hljs-keyword">P</span> <span class="hljs-keyword">Y</span>}</code> will always be executed eventually. For <code>{ByNeed <span class="hljs-keyword">P</span> <span class="hljs-keyword">Y</span>}</code>, we know that <code>{<span class="hljs-keyword">P</span> <span class="hljs-keyword">Y</span>}</code> will be executed only if the value of <code><span class="hljs-attribute">Y</span></code> is needed.</p>
<p>The browser does create a need for a value.</p>
<p>A by-need trigger is a pair <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">trig(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> of a dataflow variable <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and a one-argument procedure <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>.</p>
<p><img src="assets/2022-12-16-12-45-21.png" alt=""></p>
<p><img src="assets/2022-12-16-12-48-35.png" alt=""></p>
<h2 id="9-relational-programming-(9.1-9.3%2C-9.7)-(p.-621-641%2C-660-671)" tabindex="-1">9 Relational Programming (9.1-9.3, 9.7) (p. 621-641, 660-671)</h2>
<h3 id="9.1-the-relational-computation-model" tabindex="-1">9.1 The relational computation model</h3>
<h3 id="9.2-further-examples" tabindex="-1">9.2 Further examples</h3>
<h3 id="9.3-relation-to-logic-programming" tabindex="-1">9.3 Relation to logic programming</h3>
<p>Now we can state more precisely what a <strong>logic program</strong> is. For our purposes, a logic program consists of a set of axioms in the first-order predicate calculus, a sentence called the query, and a theorem prover, i.e., a system that can perform deduction using the axioms in an attempt to prove or disprove the query. Performing deductions is called executing the logic program.</p>
<h3 id="9.7-the-prolog-language" tabindex="-1">9.7 The Prolog language</h3>
<p>The Prolog computation model has a layered structure with three levels:</p>
<ol>
<li>The first level is a simple theorem prover that uses Horn clauses and that executes with SLDNF resolution</li>
<li>The second level consists of a series of extralogical features that are used to modify and extend the resolution-based theorem prover.</li>
<li>The third level consists of the assert/1 and retract/1 operations, which provide explicit state.</li>
</ol>
<p>One way to write good Prolog programs is to follow these three steps:</p>
<ol>
<li>Write the program as if it were a statement in pure logic.</li>
<li>Rewrite (part of) the program for efficiency, taking care not to break the logical semantics.</li>
<li>Add extralogical operations where they are needed.</li>
</ol>
<h2 id="12-constraint-programming-(p.-749-773)" tabindex="-1">12 Constraint Programming (p. 749-773)</h2>
<p>Constraint programming consists of a set of techniques for solving constraint satisfaction problems.A constraint satisfaction problem, or CSP, consists of a set of constraints on a set of variables.A constraint, in this setting, is simply a logical relation, such as ‚ÄúX is less than Y‚Äù or ‚ÄúX is a multiple of 3.‚Äù The first problem is to find whether there exists a solution, without necessarily constructing it. The second problem is to find one or more solutions.</p>
<h3 id="12.1-propagate-and-search" tabindex="-1">12.1 Propagate-and-search</h3>
<p>The propagate-and-search approach is based on three important ideas:</p>
<ol>
<li>Keep partial information.</li>
<li>Use local deduction.</li>
<li>Do controlled search.</li>
</ol>
<h3 id="12.2-programming-techniques" tabindex="-1">12.2 Programming techniques</h3>
<h3 id="12.3-the-constraint-based-computational-model" tabindex="-1">12.3 The constraint-based computational model</h3>
<h3 id="12.4-defining-and-using-computation-spaces" tabindex="-1">12.4 Defining and using computation spaces</h3>
<h3 id="12.5-implementing-the-relational-computation-model" tabindex="-1">12.5 Implementing the relational computation model</h3>

        <div style="height: 100vh;"></div>
      </article>
      </div>
  </body>
</html>
