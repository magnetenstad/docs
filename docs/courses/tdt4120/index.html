<!DOCTYPE html>
<html>

<head>
  <!-- Katex -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">

  <!-- GitHub Markdown Styles -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

  <title>index.md</title>
  <link rel="icon" type="image/x-icon" href="../../null">

  <!-- Custom Styles -->
  <link rel="stylesheet" href="../../styles.css">
  
</head>

<body>
<article class="markdown-body">

<p>↩️ <a href="../index.html">courses</a></p>
<h1>tdt4120</h1>
<h1>TDT4120 Pensumhefte, 2021</h1>
<p>Dette dokumentet ligger ute på https://magne.dev/TDT4120-notes/.
Dersom du ønsker å kjøre algoritmene, kan du klone prosjektet fra https://github.com/magnetenstad/TDT4120-notes.
Med referansen <em>kompendium</em> menes det skrevet av Mathilde Haukø Haugum (2018).</p>
<h2>Læringsmål</h2>
<h3>Overordnede læringsmål</h3>
<p>De overordnede læringsmålene for emnet er som følger.</p>
<p><strong>Dere skal ha kunnskap om:</strong></p>
<ul>
<li>[x] [X1] Et bredt spekter av etablerte algoritmer og datastrukturer</li>
<li>[x] [X2] Klassiske algoritmiske problemer med kjente effektive løsninger</li>
<li>[ ] [X3] Komplekse problemer uten kjente effektive løsninger</li>
</ul>
<p><strong>Dere skal kunne:</strong></p>
<ul>
<li>[ ] [X4] Analysere algoritmers korrekthet og effektivitet</li>
<li>[ ] [X5] Formulere problemer så de kan løses av algoritmer</li>
<li>[ ] ! [X6] Konstruere nye effektive algoritmer</li>
</ul>
<p><strong>Dere skal være i stand til:</strong></p>
<ul>
<li>[ ] [X7] Å bruke eksisterende algoritmer og programvare på nye problemer</li>
<li>[ ] [X8] Å utvikle nye løsninger på praktiske algoritmiske problemstillinger</li>
</ul>
<h3>Gjennom semesteret</h3>
<p><strong>Læringsmål for hver algoritme:</strong></p>
<ul>
<li>[x] [Z1] Kjenne den formelle definisjonen av det generelle problemet den løser</li>
<li>[x] [Z2] Kjenne til eventuelle tilleggskrav den stiller for å være korrekt</li>
<li>[x] [Z3] Vite hvordan den oppfører seg; kunne utføre algoritmen, trinn for trinn</li>
<li>[ ] ! [Z4] Forstå korrekthetsbeviset; hvordan og hvorfor virker algoritmen egentlig?</li>
<li>[ ] [Z5] Kjenne til eventuelle styrker eller svakheter, sammenlignet med andre</li>
<li>[x] [Z6] Kjenne kjøretidene under ulike omstendigheter, og forstå utregningen</li>
</ul>
<p><strong>Læringsmål for hver datastruktur:</strong></p>
<ul>
<li>[x] [Z7] Forstå algoritmene (jf. mål Z01–Z06) for de ulike operasjonene på strukturen</li>
<li>[x] [Z8] Forstå hvordan strukturen representeres i minnet</li>
</ul>
<p><strong>Læringsmål for hvert problem:</strong></p>
<ul>
<li>[x] [Z9] Kunne angi presist hva input er</li>
<li>[x] [Z10] Kunne angi presist hva output er og hvilke egenskaper det må ha</li>
</ul>
<h3>Forelesning 1: Problemer og algoritmer</h3>
<ul>
<li>[x] [A1] <a href="#a1-forst%C3%A5-bokas-pseudokode-konvensjoner">Forstå bokas pseudokode-konvensjoner</a></li>
<li>[x] [A2] <a href="#a2-kjenne-egenskapene-til-random-access-machine-modellen-ram">Kjenne egenskapene til random-access machine-modellen (RAM)</a></li>
<li>[x] [A3] <a href="#a3-kunne-definere-problem-instans-og-problemst%C3%B8rrelse">Kunne definere problem, instans og problemstørrelse</a></li>
<li>[x] ! [A4] <a href="#a4-kunne-definere-asymptotisk-notasjon-o-omega-theta-o-og-omega">Kunne definere asymptotisk notasjon, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span> og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></a></li>
<li>[x] ! [A5] <a href="#a5-kunne-definere-best-case-average-case-og-worst-case">Kunne definere best-case, average-case og worst-case</a></li>
<li>[x] ! [A6] <a href="#a6-forst%C3%A5-l%C3%B8kkeinvarianter-og-induksjon">Forstå løkkeinvarianter og induksjon</a></li>
<li>[x] ! [A7] <a href="#a7-forst%C3%A5-rekursiv-dekomponering-og-induksjon-over-delinstanser">Forstå rekursiv dekomponering og induksjon over delinstanser</a></li>
<li>[x] [A8] <a href="#a8-forst%C3%A5-insertion-sort">Forstå Insertion-Sort</a></li>
</ul>
<h3>Forelesning 2: Datastrukturer</h3>
<ul>
<li>[x] [B1] <a href="#b1-forst%C3%A5-hvordan-stakker-og-k%C3%B8er-fungerer">Forstå hvordan stakker og køer fungerer</a></li>
<li>[x] [B2] <a href="#b2-forst%C3%A5-hvordan-lenkede-lister-fungerer">Forstå hvordan lenkede lister fungerer</a></li>
<li>[x] [B3] <a href="#b3-forst%C3%A5-hvordan-pekere-og-objekter-kan-implementeres">Forstå hvordan pekere og objekter kan implementeres</a></li>
<li>[x] ! [B4] <a href="#b4-forst%C3%A5-hvordan-direkte-adressering-og-hashtabeller-fungerer">Forstå hvordan direkte adressering og hashtabeller fungerer</a></li>
<li>[x] [B5] <a href="#b5-forst%C3%A5-konfliktl%C3%B8sing-ved-kjeding-chaining">Forstå konfliktløsing ved kjeding (chaining)</a></li>
<li>[x] [B6] <a href="#b6-kjenne-til-grunnleggende-hashfunksjoner">Kjenne til grunnleggende hashfunksjoner</a></li>
<li>[x] [B7] <a href="#b7-vite-at-man-for-statiske-datasett-kan-ha-worst-case-o1-for-s%C3%B8k">Vite at man for statiske datasett kan ha worst-case O(1) for søk</a></li>
<li>[x] [B8] <a href="#b8-kunne-definere-amortisert-analyse">Kunne definere amortisert analyse</a></li>
<li>[x] [B9] <a href="#b8-kunne-definere-amortisert-analyse">Forstå hvordan dynamiske tabeller fungerer</a></li>
</ul>
<h3>Forelesning 3: Splitt og hersk</h3>
<ul>
<li>[x] ! [C1] <a href="#c1-forst%C3%A5-designmetoden-divide-and-conquer-splitt-og-hersk">Forstå designmetoden divide-and-conquer (splitt og hersk)</a></li>
<li>[x] [C2] <a href="#c2-forst%C3%A5-maximum-subarray-problemet-med-l%C3%B8sninger">Forstå maximum-subarray-problemet med løsninger</a></li>
<li>[x] [C3] <a href="#c3-forst%C3%A5-bisect-og-bisect">Forstå Bisect og Bisect'</a></li>
<li>[x] [C4] <a href="#c4-forst%C3%A5-merge-sort">Forstå Merge-Sort</a></li>
<li>[x] [C5] <a href="#c5-forst%C3%A5-quicksort-og-randomized-quicksort">Forstå Quicksortog Randomized-Quicksort</a></li>
<li>[x] ! [C6] <a href="#c6-kunne-l%C3%B8se-rekurrenser-med-substitusjon-rekursjonstr%C3%A6r-og-masterteoremet">Kunne løse rekurrenser med substitusjon, rekursjonstrær og masterteoremet</a></li>
<li>[x] ! [C7] <a href="#c7-kunne-l%C3%B8se-rekurrenser-med-iterasjonsmetoden">Kunne løse rekurrenser med iterasjonsmetoden</a></li>
<li>[x] [C8] <a href="#c8-forst%C3%A5-hvordan-variabelskifte-fungerer">Forstå hvordan variabelskifte fungerer</a></li>
</ul>
<h3>Forelesning 4: Rangering i lineær tid</h3>
<ul>
<li>[x] ! [D1] <a href="#d1-forst%C3%A5-hvorfor-sammenligningsbasert-sortering-har-en-worst-case-p%C3%A5-omegan-lg-n">Forstå hvorfor sammenligningsbasert sortering har en worst-case på <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></a></li>
<li>[x] [D2] <a href="#d2-vite-hva-en-stabil-sorteringsalgoritme-er">Vite hva en stabil sorteringsalgoritme er</a></li>
<li>[x] [D3] <a href="#d3-forst%C3%A5-counting-sort-og-hvorfor-den-er-stabil">Forstå Counting-Sort, og hvorfor den er stabil</a></li>
<li>[x] ! [D4] <a href="#d4-forst%C3%A5-radix-sort-og-hvorfor-den-trenger-en-stabil-subrutine">Forstå Radix-Sort, og hvorfor den trenger en stabil subrutine</a></li>
<li>[x] [D5] <a href="#d5-forst%C3%A5-bucket-sort">Forstå Bucket-Sort</a></li>
<li>[x] [D6] <a href="#d6-forst%C3%A5-randomized-select">Forstå Randomized-Select</a></li>
<li>[x] [D7] <a href="#d7-kjenne-til-select">Kjenne til Select</a></li>
</ul>
<h3>Forelesning 5: Rotfaste trestrukturer</h3>
<ul>
<li>[x] ! [E1] <a href="#e1-forst%C3%A5-hvordan-heaps-fungerer-og-hvordan-de-kan-brukes-som-prioritetsk%C3%B8er">Forstå hvordan heaps fungerer, og hvordan de kan brukes som prioritetskøer</a></li>
<li>[x] [E2] <a href="#e2-forst%C3%A5-heapsort">Forstå Heapsort</a></li>
<li>[x] [E3] <a href="#e3-forst%C3%A5-hvordan-rotfaste-tr%C3%A6r-kan-implementeres">Forstå hvordan rotfaste trær kan implementeres</a></li>
<li>[x] ! [E4] <a href="#e4-forst%C3%A5-hvordan-bin%C3%A6re-s%C3%B8ketr%C3%A6r-fungerer">Forstå hvordan binære søketrær fungerer</a></li>
<li>[x] [E5] <a href="#e5-vite-at-forventet-h%C3%B8yde-for-et-tilfeldig-bin%C3%A6rt-s%C3%B8ketre-er-thetalg-n">Vite at forventet høyde for et tilfeldig binært søketre er <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></a></li>
<li>[x] [E6] <a href="#e6-vite-at-det-finnes-s%C3%B8ketr%C3%A6r-med-garantert-h%C3%B8yde-p%C3%A5-thetalg-n">Vite at det finnes søketrær med garantert høyde på <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></a></li>
</ul>
<h3>Forelesning 6: Dynamisk programmering</h3>
<ul>
<li>[x] ! [F1] <a href="#f1-forst%C3%A5-ideen-om-en-delinstansgraf">Forstå ideen om en delinstansgraf</a></li>
<li>[x] ! [F2] <a href="#f2-forst%C3%A5-designmetoden-dynamisk-programmering">Forstå designmetoden dynamisk programmering</a></li>
<li>[x] ! [F3] <a href="#f3-forst%C3%A5-l%C3%B8sning-ved-memoisering-top-down">Forstå løsning ved memoisering (top-down)</a></li>
<li>[x] [F4] <a href="#f4-forst%C3%A5-l%C3%B8sning-ved-iterasjon-bottom-up">Forstå løsning ved iterasjon (bottom-up)</a></li>
<li>[x] [F5] <a href="#f5-forst%C3%A5-hvordan-man-rekonstruerer-en-l%C3%B8sning-fra-lagrede-beslutninger">Forstå hvordan man rekonstruerer en løsning fra lagrede beslutninger</a></li>
<li>[x] [F6] <a href="#f6-forst%C3%A5-hva-optimal-delstruktur-er">Forstå hva optimal delstruktur er</a></li>
<li>[x] [F7] <a href="#f7-forst%C3%A5-hva-overlappende-delinstanser-er">Forstå hva overlappende delinstanser er</a></li>
<li>[x] [F8] <a href="#f8-forst%C3%A5-eksemplene-stavkutting-og-lcs">Forstå eksemplene stavkutting og LCS</a></li>
<li>[x] [F9] <a href="#f9-forst%C3%A5-l%C3%B8sningen-p%C3%A5-det-bin%C3%A6re-ryggsekkproblemet">Forstå løsningen på det binære ryggsekkproblemet</a></li>
</ul>
<h3>Forelesning 7: Grådige algoritmer</h3>
<ul>
<li>[x] ! [G1] <a href="#g1-forst%C3%A5-designmetoden-gr%C3%A5dighet">Forstå designmetoden grådighet</a></li>
<li>[x] ! [G2] <a href="#g2-forst%C3%A5-gr%C3%A5dighetsegenskapen-the-greedy-choice-property">Forstå grådighetsegenskapen (the greedy-choice property)</a></li>
<li>[x] [G3] <a href="#g3-forst%C3%A5-eksemplene-aktivitet-utvelgelse-og-det-kontinuerlige-ryggsekkproblemet">Forstå eksemplene aktivitet-utvelgelse og det kontinuerlige ryggsekkproblemet</a></li>
<li>[x] [G4] <a href="#g4-forst%C3%A5-huffman-og-huffman-koder">Forstå Huffman og Huffman-koder</a></li>
</ul>
<h3>Forelesning 8: Traversering av grafer</h3>
<ul>
<li>[x] [H1] <a href="#h1-forst%C3%A5-hvordan-grafer-kan-implementeres">Forstå hvordan grafer kan implementeres</a></li>
<li>[x] [H2] <a href="#h2-forst%C3%A5-bfs-ogs%C3%A5-for-%C3%A5-finne-korteste-vei-uten-vekter">Forstå BFS, også for å finne korteste vei uten vekter</a></li>
<li>[x] [H3] <a href="#h3-forst%C3%A5-dfs-parentesteoremet-og-hvit-sti-teoremet">Forstå DFS, parentesteoremet og hvit-sti-teoremet</a></li>
<li>[x] [H4] <a href="#h4-forst%C3%A5-hvordan-dfs-klassifiserer-kanter">Forstå hvordan DFS klassifiserer kanter</a></li>
<li>[x] [H5] <a href="#h5-forst%C3%A5-topological-sort">Forstå Topological-Sort</a></li>
<li>[x] [H6] <a href="#h6-forst%C3%A5-hvordan-dfs-kan-implementeres-med-en-stakk">Forstå hvordan DFS kan implementeres med en stakk</a></li>
<li>[x] [H7] <a href="#h7-forst%C3%A5-hva-traverseringstr%C3%A6r-som-bredde-f%C3%B8rst--og-dybde-f%C3%B8rst-tr%C3%A6r-er">Forstå hva traverseringstrær (som bredde-først- og dybde-først-trær) er</a></li>
<li>[x] ! [H8] <a href="#h8-forst%C3%A5-traversering-med-vilk%C3%A5rlig-prioritetsk%C3%B8">Forstå traversering med vilkårlig prioritetskø</a></li>
</ul>
<h3>Forelesning 9: Minimale spenntrær</h3>
<ul>
<li>[x] [I1] <a href="#i1-forst%C3%A5-skog-implementasjonen-av-disjunkte-mengder">Forstå skog-implementasjonen av disjunkte mengder</a></li>
<li>[x] [I2] <a href="#i2-vite-hva-spenntr%C3%A6r-og-minimale-spenntr%C3%A6r-er">Vite hva spenntrær og minimale spenntrær er</a></li>
<li>[x] ! [I3] <a href="#i3-forst%C3%A5-generic-mst">Forstå Generic-MST</a></li>
<li>[x] [I4] <a href="#i4-forst%C3%A5-hvorfor-lette-kanter-er-trygge-kanter">Forstå hvorfor lette kanter er trygge kanter</a></li>
<li>[x] [I5] <a href="#i5-forst%C3%A5-mst-kruskal">Forstå MST-Kruskal</a></li>
<li>[x] [I6] <a href="#i6-forst%C3%A5-mst-prim">Forstå MST-Prim</a></li>
</ul>
<h3>Forelesning 10: Korteste vei fra én til alle</h3>
<ul>
<li>[x] [J1] <a href="#j1-forst%C3%A5-ulike-varianter-av-korteste-vei--eller-korteste-sti-problemet">Forstå ulike varianter av korteste-vei- eller korteste-sti-problemet</a></li>
<li>[x] [J2] <a href="#j2-forst%C3%A5-strukturen-til-korteste-vei-problemet">Forstå strukturen til korteste-vei-problemet</a></li>
<li>[x] [J3] <a href="#j3-forst%C3%A5-at-negative-sykler-gir-mening-for-korteste-enkle-vei-simple-path">Forstå at negative sykler gir mening for korteste enkle vei (simple path)</a></li>
<li>[x] [J4] <a href="#j4-forst%C3%A5-at-korteste-enkle-vei-kan-l%C3%B8ses-vha-lengste-enkle-vei-og-omvendt">Forstå at korteste enkle vei kan løses vha. lengste enkle vei og omvendt</a></li>
<li>[x] [J5] <a href="#j5-forst%C3%A5-hvordan-man-kan-representere-et-korteste-vei-tre">Forstå hvordan man kan representere et korteste-vei-tre</a></li>
<li>[x] ! [J6] <a href="#j6-forst%C3%A5-kant-slakking-edge-relaxation-og-relax">Forstå kant-slakking (edge relaxation) og Relax</a></li>
<li>[x] [J7] <a href="#j7-forst%C3%A5-ulike-egenskaper-ved-korteste-veier-og-slakking">Forstå ulike egenskaper ved korteste veier og slakking</a></li>
<li>[x] [J8] <a href="#j8-forst%C3%A5-bellman-ford">Forstå Bellman-Ford</a></li>
<li>[x] [J9] <a href="#j9-forst%C3%A5-dag-shortest-paths">Forstå Dag-Shortest-Paths</a></li>
<li>[x] ! [J10] <a href="#j10-forst%C3%A5-kobling-mellom-dag-shortest-paths-og-dynamisk-programmering">Forstå kobling mellom Dag-Shortest-Paths og dynamisk programmering</a></li>
<li>[x] [J11] <a href="#j11-forst%C3%A5-dijkstra">Forstå Dijkstra</a></li>
</ul>
<h3>Forelesning 11: Korteste vei fra alle til alle</h3>
<ul>
<li>[x] [K1] <a href="#k1-forst%C3%A5-forgjengerstrukturen-for-alle-til-alle-varianten-av-korteste-vei-problemet">Forstå forgjengerstrukturen for alle-til-alle-varianten av korteste vei-problemet</a></li>
<li>[x] [K2] <a href="#k2-forst%C3%A5-floyd-warshall">Forstå Floyd-Warshall</a></li>
<li>[x] [K3] <a href="#k3-forst%C3%A5-transitive-closure">Forstå Transitive-Closure</a></li>
<li>[x] [K4] <a href="#k4-forst%C3%A5-johnson">Forstå Johnson</a></li>
</ul>
<h3>Forelesning 12: Maksimal flyt</h3>
<ul>
<li>[x] [L1] <a href="#l1-kunne-definere-flytnett-flyt-og-maks-flyt-problemet">Kunne definere flytnett, flyt og maks-flyt-problemet</a></li>
<li>[x] [L2] <a href="#l2-kunne-h%C3%A5ndtere-antiparallelle-kanter-og-flere-kilder-og-sluk">Kunne håndtere antiparallelle kanter og flere kilder og sluk</a></li>
<li>[x] ! [L3] <a href="#l3-kunne-definere-restnettet-til-et-flytnett-med-en-gitt-flyt">Kunne definere restnettet til et flytnett med en gitt flyt</a></li>
<li>[x] [L4] <a href="#l4-forst%C3%A5-hvordan-man-kan-oppheve-cancel-flyt">Forstå hvordan man kan oppheve (cancel) flyt</a></li>
<li>[x] [L5] <a href="#l5-forst%C3%A5-hva-en-for%C3%B8kende-sti-augmenting-path-er">Forstå hva en forøkende sti (augmenting path) er</a></li>
<li>[x] [L6] <a href="#l6-forst%C3%A5-hva-snitt-snitt-kapasitet-og-minimalt-snitt-er">Forstå hva snitt, snitt-kapasitet og minimalt snitt er</a></li>
<li>[x] ! [L7] <a href="#l7-forst%C3%A5-maks-flytmin-snitt-teoremet">Forstå maks-flyt/min-snitt-teoremet</a></li>
<li>[x] [L8] <a href="#l8-forst%C3%A5-ford-fulkerson-method-og-ford-fulkerson">Forstå Ford-Fulkerson-Method og Ford-Fulkerson</a></li>
<li>[x] [L9] <a href="#l9-vite-at-ford-fulkerson-med-bfs-kalles-edmonds-karp-algoritmen">Vite at Ford-Fulkerson med BFS kalles Edmonds-Karp-algoritmen</a></li>
<li>[x] [L10] <a href="#l10-forst%C3%A5-hvordan-maks-flyt-kan-finne-en-maksimum-bipartitt-matching">Forstå hvordan maks-flyt kan finne en maksimum bipartitt matching</a></li>
<li>[x] ! [L11] <a href="#l11-forst%C3%A5-heltallsteoremet-integrality-theorem">Forstå heltallsteoremet (integrality theorem)</a></li>
</ul>
<h3>Forelesning 13: NP-kompletthet</h3>
<ul>
<li>[x] [M1] <a href="#m1-forst%C3%A5-sammenhengen-mellom-optimerings--og-beslutnings-problemer">Forstå sammenhengen mellom optimerings- og beslutnings-problemer</a></li>
<li>[x] [M2] <a href="#m2-forst%C3%A5-koding-encoding-av-en-instans">Forstå koding (encoding) av en instans</a></li>
<li>[x] [M3] <a href="#m3-forst%C3%A5-hvorfor-l%C3%B8sningen-p%C3%A5-det-bin%C3%A6re-ryggsekkproblemet-ikke-er-polynomisk">Forstå hvorfor løsningen på det binære ryggsekkproblemet ikke er polynomisk</a></li>
<li>[x] [M4] <a href="#m4-forst%C3%A5-forskjellen-p%C3%A5-konkrete-og-abstrakte-problemer">Forstå forskjellen på konkrete og abstrakte problemer</a></li>
<li>[x] [M5] <a href="#m5-forst%C3%A5-representasjonen-av-beslutningsproblemer-som-formelle-spr%C3%A5k">Forstå representasjonen av beslutningsproblemer som formelle språk</a></li>
<li>[x] [M6] <a href="#m6-forst%C3%A5-definisjonen-av-klassene-p-np-og-co-np">Forstå definisjonen av klassene P, NP og co-NP</a></li>
<li>[x] [M7] <a href="#m7-forst%C3%A5-redusibilitets-relasjonen-leq_p">Forstå redusibilitets-relasjonen <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≤</mo><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\leq_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mrel"><span class="mrel">≤</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></a></li>
<li>[x] ! [M8] <a href="#m8-forst%C3%A5-definisjonen-av-np-hardhet-og-np-kompletthet">Forstå definisjonen av NP-hardhet og NP-kompletthet</a></li>
<li>[x] [M9] <a href="#m9-forst%C3%A5-den-konvensjonelle-hypotesen-om-forholdet-mellom-p-np-og-npc">Forstå den konvensjonelle hypotesen om forholdet mellom P, NP og NPC</a></li>
<li>[x] ! [M10] <a href="#m10-forst%C3%A5-hvordan-np-kompletthet-kan-bevises-ved-%C3%A9n-reduksjon">Forstå hvordan NP-kompletthet kan bevises ved én reduksjon</a></li>
<li>[x] ! [M11] <a href="#m11-kjenne-de-np-komplette-problemene-circuit-sat-sat-3-cnf-sat-clique-vertex-cover-ham-cycle-tsp-og-subset-sum">Kjenne de NP-komplette problemene CIRCUIT-SAT, SAT, 3-CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP og SUBSET-SUM</a></li>
<li>[x] [M12] <a href="#m12-forst%C3%A5-at-det-bin%C3%A6re-ryggsekkproblemet-er-np-hardt">Forstå at det binære ryggsekkproblemet er NP-hardt</a></li>
<li>[x] [M13] <a href="#m13-forst%C3%A5-at-lengste-enkle-vei-problemet-er-np-hardt">Forstå at lengste enkle-vei-problemet er NP-hardt</a></li>
<li>[x] [M14] <a href="#m14-v%C3%A6re-i-stand-til-%C3%A5-konstruere-enkle-np-kompletthetsbevis">Være i stand til å konstruere enkle NP-kompletthetsbevis</a></li>
</ul>
<h3>Forelesning 1: Problemer og algoritmer</h3>
<h4>[A1] Forstå bokas pseudokode-konvensjoner</h4>
<p>Bokas pseudokode-konvensjoner er generelt enkle å forstå. Det er likevel verdt å merke seg at det som regel brukes 1-indeksering, mens koden i dette dokumentet vil bruke 0-indeksering, fordi det her er implementert i Python.</p>
<h4>[A2] Kjenne egenskapene til random-access machine-modellen (RAM)</h4>
<p>Before we can analyze an algorithm, we must have a model of the implementation technology that we will use. The RAM model contains instructions commonly found in real computers: arithmetic (such as add, subtract, multiply, divide, remainder, floor, ceiling), data movement (load, store, copy), and control (conditional and unconditional branch, subroutine call and return). Each such instruction takes a constant amount of time. What if a RAM had an instruction that sorts? Then we could sort in just one instruction. Such a RAM would be unrealistic, since real computers do not have such instructions.</p>
<h4>[A3] Kunne definere problem, instans og problemstørrelse</h4>
<ul>
<li>Algoritme: Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output. An algorithm is thus a sequence of computational steps that transform the input into the output.</li>
<li>Problem: The statement of the problem specifies in general terms the desired input/output relationship.</li>
<li>Probleminstans: In general, an instance of a problem consists of the input (satisfying whatever constraints are imposed in the problem statement) needed to compute a solution to the problem.</li>
<li>Problemstørrelse: Størrelse på input tilhørende en probleminstans, f.eks. antall tall som skal sorteres i et sorteringsproblem.</li>
</ul>
<h4>[A4] Kunne definere asymptotisk notasjon, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span> og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></h4>
<table>
<thead>
<tr>
<th>Notasjon</th>
<th>Forklaring</th>
<th>Tegn</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></td>
<td>streng nedre grense</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span></td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span></td>
<td>nedre grense</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span></td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span></td>
<td>øvre og nedre grense</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span></td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></td>
<td>øvre grense</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span></td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span></td>
<td>streng øvre grense</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span></td>
</tr>
</tbody>
</table>
<h4>[A5] Kunne definere best-case, average-case og worst-case</h4>
<p><strong>Best-case</strong> er den minimale kjøretiden, gitt et optimalt input. <strong>Average-case</strong> er den gjennomsnittlige kjøretiden, over alle mulige inputs. <strong>Worst-case</strong> er den maksimale kjøretiden, gitt verst tenkelig input.</p>
<h4>[A6] Forstå løkkeinvarianter og induksjon</h4>
<p><strong>Løkkeinvariant</strong>: et krav tilfredsstilles etter hver iterasjon, brukes til bevis.
<strong>Induksjon</strong>: Grunntilfelle + induktivt steg kan gi et bevis for alle n &gt; grunntilfellet.</p>
<h4>[A7] Forstå rekursiv dekomponering og induksjon over delinstanser</h4>
<p><strong>Rekursiv dekomponering</strong>: Del instansen i mindre biter, løs problemet rekursivt for disse, og kombinér løsningene.</p>
<h4>[A8] Forstå Insertion-Sort</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Insertion-Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme</td>
</tr>
<tr>
<td>Input</td>
<td>A: vilkårlig liste av tall</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste (in place)</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, hvis input er omvendt sortert</td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, hvis input allerede er sortert</td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>True</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
<tr>
<td>Løkkeinvariant</td>
<td>For hver iterasjon er delarrayet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>1</mn><mo>…</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[1 \dots j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> sortert, og element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> plasseres slik at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>1</mn><mo>…</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[1 \dots j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> blir sortert.</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">A</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(A)):
        key = A[j]
        <span class="hljs-comment"># Insert A[j] into the sorted sequence A[0 .. j - 1]</span>
        i = j - <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[i] &gt; key:
            A[i + <span class="hljs-number">1</span>] = A[i]
            i -= <span class="hljs-number">1</span>
        A[i + <span class="hljs-number">1</span>] = key
</code></pre>
<p><a href="/lib/insertion_sort.py">Implementasjon av Insertion-Sort</a></p>
<h3>Forelesning 2: Datastrukturer</h3>
<h4>[B1] Forstå hvordan stakker og køer fungerer</h4>
<h5>Stakker</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Stack-Empty</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sjekker om stakken er tom</td>
</tr>
<tr>
<td>Input</td>
<td>S: stakk</td>
</tr>
<tr>
<td>Output</td>
<td>True hvis stakken er tom, False ellers</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Push</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Legger til et element på stakken</td>
</tr>
<tr>
<td>Input</td>
<td>S: stakk, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Pop</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjerner og returnerer øverste element av stakken</td>
</tr>
<tr>
<td>Input</td>
<td>S: stakk</td>
</tr>
<tr>
<td>Output</td>
<td>Elementet på toppen av stakken</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">stack_empty</span>(<span class="hljs-params">S</span>):
    <span class="hljs-keyword">return</span> S.top == <span class="hljs-number">0</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">S, x</span>):
    S.top += <span class="hljs-number">1</span>
    S[S.top] = x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">S</span>):
    <span class="hljs-keyword">if</span> stack_empty(S):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR: underflow"</span>)
    <span class="hljs-keyword">else</span>:
        S.top -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> S[S.top + <span class="hljs-number">1</span>]
</code></pre>
<p><a href="lib/structures/stack.py">Implementasjon av stakker</a></p>
<h5>Køer</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Enqueue</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Legger til et element på halen til køen</td>
</tr>
<tr>
<td>Input</td>
<td>Q: kø</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Dequeue</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjerner og returnerer elementet som står først i køen</td>
</tr>
<tr>
<td>Input</td>
<td>Q: kø</td>
</tr>
<tr>
<td>Output</td>
<td>Det første elementet i køen</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">Q, x</span>):
    Q[Q.tail] = x
    <span class="hljs-keyword">if</span> Q.tail == Q.length:
        Q.tail = <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span>:
        Q.tail += <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dequeue</span>(<span class="hljs-params">Q</span>):
    x = Q[Q.head]
    <span class="hljs-keyword">if</span> Q.head == Q.length:
        Q.head = <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span>:
        Q.head += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> x
</code></pre>
<p><a href="lib/structures/queue.py">Implementasjon av køer</a></p>
<h4>[B2] Forstå hvordan lenkede lister fungerer</h4>
<p>TODO: List-Delete', List-Search', List-Insert'</p>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>List-Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Søker etter et element med en spesifikk nøkkel</td>
</tr>
<tr>
<td>Input</td>
<td>L: lenket liste, k: nøkkel</td>
</tr>
<tr>
<td>Output</td>
<td>Elementet med nøkkelen, eller NIL</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>List-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Legger et element til starten av en lenket liste</td>
</tr>
<tr>
<td>Input</td>
<td>L: lenket liste, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>List-Delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjernet et element fra en dobbeltlenket liste</td>
</tr>
<tr>
<td>Input</td>
<td>L: dobbeltlenket liste, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_search</span>(<span class="hljs-params">L, k</span>):
    x = L.head
    <span class="hljs-keyword">while</span> x != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> x.key != k:
        x = x.<span class="hljs-built_in">next</span>
    <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">list_insert</span>(<span class="hljs-params">L, x</span>):
    x.<span class="hljs-built_in">next</span> = L.head
    <span class="hljs-keyword">if</span> L.head != <span class="hljs-literal">None</span>:
        L.head.prev = x
    L.head = x
    x.prev = <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">list_delete</span>(<span class="hljs-params">L, x</span>):
    <span class="hljs-keyword">if</span> x.prev != <span class="hljs-literal">None</span>:
        x.prev.<span class="hljs-built_in">next</span> = x.<span class="hljs-built_in">next</span>
    <span class="hljs-keyword">else</span>:
        L.head = x.<span class="hljs-built_in">next</span>
    <span class="hljs-keyword">if</span> x.<span class="hljs-built_in">next</span> != <span class="hljs-literal">None</span>:
        x.<span class="hljs-built_in">next</span>.prev = x.prev
</code></pre>
<p><a href="lib/structures/linked_list.py">Implementasjon av lenkede lister</a></p>
<h4>[B3] Forstå hvordan pekere og objekter kan implementeres</h4>
<p>Pekere og objekter kan implementeres ved lister og indekser. Indeksene fungerer som pekere. Det er to måter å gjøre dette på:</p>
<ol>
<li>Feltene/attributtene i objektet plassereres i separate lister</li>
<li>Én liste holder av en viss lengde til hvert objekt slik at det får plass til attributtene</li>
</ol>
<h4>[B4] Forstå hvordan direkte adressering og hashtabeller fungerer</h4>
<h5>Direkte adressering</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Direct-Address-Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Henter et element fra en direct-access-tabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: direct-access-tabell, k: nøkkel</td>
</tr>
<tr>
<td>Output</td>
<td>Elementet i tabellen med den gitt nøkkelen, eller None</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Direct-Address-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter et element inn i en direct-access-tabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: direct-access-tabell, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Direct-Address-Delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sletter et element i en direct-access-tabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: direct-access-tabell, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">direct_address_search</span>(<span class="hljs-params">T, k</span>):
    <span class="hljs-keyword">return</span> T[k]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">direct_address_insert</span>(<span class="hljs-params">T, x</span>):
    T[x.key] = x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">direct_address_delete</span>(<span class="hljs-params">T, x</span>):
    T[x.key] = <span class="hljs-literal">None</span>
</code></pre>
<h5>Hashtabeller</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Hash-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter et element inn i en hashtabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: hashtabell, x: element</td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average/worst case</td>
<td>Spørs på hashfunksjonen</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Hash-Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Henter et element fra en hashtabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: hashtabell, k: nøkkel</td>
</tr>
<tr>
<td>Output</td>
<td>Elementet i tabellen med den gitt nøkkelen, eller None</td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average/worst case</td>
<td>Spørs på hashfunksjonen</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hash_insert</span>(<span class="hljs-params">T, k</span>):
    i = <span class="hljs-number">0</span>
    j = h(k, i)
    <span class="hljs-keyword">if</span> T[j] == <span class="hljs-literal">None</span>:
        T[j] = k
        <span class="hljs-keyword">return</span> j
    i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i != T.m:
        j = h(k, i)
        <span class="hljs-keyword">if</span> T[j] == <span class="hljs-literal">None</span>:
            T[j] = k
            <span class="hljs-keyword">return</span> j
        i += <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hash_search</span>(<span class="hljs-params">T, k</span>):
    i = <span class="hljs-number">0</span>
    j = h(k, i)
    <span class="hljs-keyword">if</span> T[j] == k:
        <span class="hljs-keyword">return</span> j
    i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> T[j] != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> i != T.m:
        j = h(k, i)
        <span class="hljs-keyword">if</span> T[j] == k:
            <span class="hljs-keyword">return</span> j
        i += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
<p><a href="lib/structures/hash_table_open_address.py">Implementasjon av hashtabeller</a></p>
<h4>[B5] Forstå konfliktløsing ved kjeding (chaining)</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Chained-Hash-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter et element inn i en kjedet hashtabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: kjedet hashtabell, x: element</td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average/worst case</td>
<td>Spørs på hashfunksjonen</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Chained-Hash-Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Henter et element fra en kjedet hashtabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: kjedet hashtabell, k: nøkkel</td>
</tr>
<tr>
<td>Output</td>
<td>Elementet i tabellen med den gitt nøkkelen, eller None</td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average/worst case</td>
<td>Spørs på hashfunksjonen</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Chained-Hash-Delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sletter et element i en kjedet hashtabell</td>
</tr>
<tr>
<td>Input</td>
<td>T: kjedet hashtabell, x: element</td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average/worst case</td>
<td>Spørs på hashfunksjonen</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">chained_hash_insert</span>(<span class="hljs-params">T, x</span>):
    T[h(x.key)].append(x)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">chained_hash_search</span>(<span class="hljs-params">T, k</span>):
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> T[h(k)]:
        <span class="hljs-keyword">if</span> x.key == k:
            <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">chained_hash_delete</span>(<span class="hljs-params">T, x</span>):
    T[h(x.key)].remove(x)
</code></pre>
<p><a href="lib/structures/hash_table_chained.py">Implementasjon av kjeding</a></p>
<h4>[B6] Kjenne til grunnleggende hashfunksjoner</h4>
<p>En god hashfunksjon vil tilnærmet tilfredsstille antagelsen om simpel uniform hashing, altså at hver key er like sannsynlig å hashe til enhver av de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> lukene, uavhengig av hvor andre keys har hashet.</p>
<ul>
<li>Divisjonsmetoden, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">h(k) = k \mod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span></li>
<li>Multiplikasjonsmetoden <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>k</mi><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k) = floor(m(ka \mod 1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4>[B7] Vite at man for statiske datasett kan ha worst-case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> for søk</h4>
<p>For statiske datasett kan vi konstruere <em>perfekte</em> hashfunksjoner, og dermed oppnå <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> for søk.</p>
<h4>[B8] Kunne definere amortisert analyse</h4>
<p>Average case og amortisert kjøretid kan fremstå som litt like til å starte med, siden de begge ser på et gjennomsnitt. Men, mens average case ser på gjennomsnitt på tvers av alle mulige individuelle instanser, så handler amortisert kjøretid om å se på gjennomsnitt på tvers av en rekke av etterfølgende verste-tilfelle invokasjoner. Altså, handler gjennomsnittet i amortisert kjøretid om invokasjoner som ikke utføres uavhengig av hverandre.</p>
<p>Ta for eksempel det typiske eksempelet med en dynamisk tabell. Når vi ser på amortisert kjøretid i dette tilfellet, så ser vi på den gjennomsnittlige kjøretiden for en innsettelse, i verste tilfelle, når vi setter inn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> elementer etter hverandre i samme instans av datastrukturen.</p>
<h4>[B9] Forstå hvordan dynamiske tabeller fungerer</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Table-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Legger til et element i en dynamisk tabell, dobler størrelsen dersom full</td>
</tr>
<tr>
<td>Input</td>
<td>T: dynamisk tabell, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, amortisert</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Table-Delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjerner et element fra en dynamisk tabell, halverer størrelsen dersom kun <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> er i bruk</td>
</tr>
<tr>
<td>Input</td>
<td>T: dynamisk tabell, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, amortisert</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">table_insert</span>(<span class="hljs-params">T, x</span>):
    <span class="hljs-keyword">if</span> T.size == <span class="hljs-number">0</span>:
        T.table = [<span class="hljs-literal">None</span>]
        T.size = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> T.num == T.size:
        new_table = [<span class="hljs-literal">None</span>] * (T.size * <span class="hljs-number">2</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(T.table)):
            new_table[i] = T.table[i]
        T.table = new_table
        T.size *= <span class="hljs-number">2</span>
    T.table[T.num] = x
    T.num += <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">table_delete</span>(<span class="hljs-params">T, x</span>):
    T.table[T.table.index(x)] = <span class="hljs-literal">None</span>
    T.num -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> T.num &lt; T.size//<span class="hljs-number">4</span>:
        new_table = [<span class="hljs-literal">None</span>] * (T.size//<span class="hljs-number">2</span>)
        j = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(T.table)):
            <span class="hljs-keyword">if</span> T.table[i] != <span class="hljs-literal">None</span>:
                new_table[j] = T.table[i]
                j += <span class="hljs-number">1</span>
        T.table = new_table
        T.size //= <span class="hljs-number">2</span>
</code></pre>
<p><a href="lib/structures/table.py">Implementasjon av dynamiske tabeller</a></p>
<h3>Forelesning 3: Splitt og hersk</h3>
<h4>[C1] Forstå designmetoden divide-and-conquer (splitt og hersk)</h4>
<ol>
<li>Divide: Dele opp i subproblemer</li>
<li>Conquer: Løse subproblemene</li>
<li>Combine: Kombinere løsningene til en større løsning</li>
</ol>
<h4>[C2] Forstå maximum-subarray-problemet med løsninger</h4>
<h5>Find-Maximum-Subarray</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Find-Maximum-Subarray</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner subarrayet i et array med størst sum av elementer</td>
</tr>
<tr>
<td>Input</td>
<td>A: array, low: laveste indeks, high: største indeks</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_max_crossing_subarray</span>(<span class="hljs-params">A, low, mid, high</span>):
    left_sum = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    _<span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mid, low - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        _<span class="hljs-built_in">sum</span> += A[i]
        <span class="hljs-keyword">if</span> _<span class="hljs-built_in">sum</span> &gt; left_sum:
            left_sum = _<span class="hljs-built_in">sum</span>
            max_left = i
    right_sum = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    _<span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mid + <span class="hljs-number">1</span>, high + <span class="hljs-number">1</span>):
        _<span class="hljs-built_in">sum</span> += A[j]
        <span class="hljs-keyword">if</span> _<span class="hljs-built_in">sum</span> &gt; right_sum:
            right_sum = _<span class="hljs-built_in">sum</span>
            max_right = j
    <span class="hljs-keyword">return</span> max_left, max_right, left_sum + right_sum

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_maximum_subarray</span>(<span class="hljs-params">A, low, high</span>):
    <span class="hljs-keyword">if</span> high == low:
        <span class="hljs-keyword">return</span> (low, high, A[low])
    <span class="hljs-keyword">else</span>:
        mid = floor((low + high) / <span class="hljs-number">2</span>)
        left_low, left_high, left_sum = find_maximum_subarray(A, low, mid)
        right_low, right_high, right_sum = find_maximum_subarray(A, mid + <span class="hljs-number">1</span>, high)
        cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high)
        <span class="hljs-keyword">if</span> left_sum &gt;= right_sum <span class="hljs-keyword">and</span> left_sum &gt;= cross_sum:
            <span class="hljs-keyword">return</span> left_low, left_high, left_sum
        <span class="hljs-keyword">elif</span> right_sum &gt;= left_sum <span class="hljs-keyword">and</span> right_sum &gt;= cross_sum:
            <span class="hljs-keyword">return</span> right_low, right_high, right_sum
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> cross_low, cross_high, cross_sum
</code></pre>
<p><a href="lib/find_maximum_subarray.py">Implementasjon maximum-subarray-problemet</a></p>
<h4>[C3] Forstå Bisect og Bisect'</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Bisect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Binærsøk, søker i en sortert liste</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-selector-tag">A</span></code>: sortert liste, <code><span class="hljs-selector-tag">p</span></code>: minste indeks, <code><span class="hljs-attribute">r</span></code>: største indeks, <code><span class="hljs-attribute">v</span></code>: verdi som søkes etter</td>
</tr>
<tr>
<td>Output</td>
<td>Indeksen til verdien det søkes etter</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, hvis <code><span class="hljs-attribute">v</span></code> er i midten</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bisect</span>(<span class="hljs-params">A, p, r, v</span>):
    <span class="hljs-keyword">if</span> p &lt;= r:
        q = floor((p + r) / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">if</span> v == A[q]:
            <span class="hljs-keyword">return</span> q
        <span class="hljs-keyword">elif</span> v &lt; A[q]:
            <span class="hljs-keyword">return</span> bisect(A, p, q - <span class="hljs-number">1</span>, v)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> bisect(A, q + <span class="hljs-number">1</span>, r, v)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative_bisect</span>(<span class="hljs-params">A, p, r, v</span>):
    <span class="hljs-keyword">while</span> p &lt;= r:
        q = floor((p + r) / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">if</span> v == A[q]:
            <span class="hljs-keyword">return</span> q
        <span class="hljs-keyword">elif</span> v &lt; A[q]:
            r = q - <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            p = q + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
<p><a href="lib/bisect.py">Implementasjon av Bisect</a></p>
<h4>[C4] Forstå Merge-Sort</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Merge-Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme</td>
</tr>
<tr>
<td>Input</td>
<td>A: vilkårlig liste av tall, p: minste indeks, r: største indeks</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>False</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Merge</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter sammen to sorterte dellister til en sortert liste</td>
</tr>
<tr>
<td>Input</td>
<td>A: liste med to sorterte dellister, p: minste indeks, q: indeksen som splitter listene r: største indeks</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>False</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">A, p, q, r</span>):
    n1 = q - p + <span class="hljs-number">1</span>
    n2 = r - q
    L = [<span class="hljs-number">0</span>] * (n1 + <span class="hljs-number">1</span>)
    R = [<span class="hljs-number">0</span>] * (n2 + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1):
        L[i] = A[p + i]
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n2):
        R[j] = A[q + j + <span class="hljs-number">1</span>]
    L[n1] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    R[n2] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    i = <span class="hljs-number">0</span>
    j = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">if</span> L[i] &lt;= R[j]:
            A[k] = L[i]
            i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            A[k] = R[j]
            j += <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">A, p, r</span>):
    <span class="hljs-keyword">if</span> p &lt; r:
        q = floor((p + r) / <span class="hljs-number">2</span>)
        merge_sort(A, p, q)
        merge_sort(A, q + <span class="hljs-number">1</span>, r)
        merge(A, p, q, r)
</code></pre>
<p><a href="lib/merge_sort.py">Implementasjon Merge-Sort</a></p>
<h4>[C5] Forstå Quicksort og Randomized-Quicksort</h4>
<h5>Quicksort</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Quicksort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme</td>
</tr>
<tr>
<td>Input</td>
<td>A: vilkårlig liste av tall, p: minste indeks, r: største indeks</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, hvis input er sortert</td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>True</td>
</tr>
<tr>
<td>Stabil</td>
<td>False</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">A, p, r</span>):
    x = A[r]
    i = p - <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p, r):
        <span class="hljs-keyword">if</span> A[j] &lt;= x:
            i += <span class="hljs-number">1</span>
            A[i], A[j] = A[j], A[i]
    A[i+<span class="hljs-number">1</span>], A[r] = A[r], A[i+<span class="hljs-number">1</span>]
    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">quicksort</span>(<span class="hljs-params">A, p, r</span>):
    <span class="hljs-keyword">if</span> p &lt; r:
        q = partition(A, p, r)
        quicksort(A, p, q - <span class="hljs-number">1</span>)
        quicksort(A, q + <span class="hljs-number">1</span>, r)
</code></pre>
<p><a href="lib/quicksort.py">Implementasjon av Quicksort</a></p>
<h5>Randomized-Quicksort</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Quicksort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme</td>
</tr>
<tr>
<td>Input</td>
<td>A: vilkårlig liste av tall, p: minste indeks, r: største indeks</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td><em>Forventet</em> worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>True</td>
</tr>
<tr>
<td>Stabil</td>
<td>False</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">randomized_partition</span>(<span class="hljs-params">A, p, r</span>):
    i = randint(p, r)
    A[i], A[r] = A[r], A[i]
    <span class="hljs-keyword">return</span> partition(A, p, r)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">randomized_quicksort</span>(<span class="hljs-params">A, p, r</span>):
    <span class="hljs-keyword">if</span> p &lt; r:
        q = randomized_partition(A, p, r)
        randomized_quicksort(A, p, q - <span class="hljs-number">1</span>)
        randomized_quicksort(A, q + <span class="hljs-number">1</span>, r)
</code></pre>
<p><a href="lib/randomized_select.py">Implementasjon av Randomized-Quicksort</a></p>
<h4>[C6] Kunne løse rekurrenser med substitusjon, rekursjonstrær og masterteoremet</h4>
<p>Se kompendium s. 37.</p>
<h4>[C7] Kunne løse rekurrenser med iterasjonsmetoden</h4>
<p>Se kompendium s. 54.</p>
<h4>[C8] Forstå hvordan variabelskifte fungerer</h4>
<p>Se kompendium s. 42.</p>
<h3>Forelesning 4: Rangering i lineær tid</h3>
<h4>[D1] Forstå hvorfor sammenligningsbasert sortering har en worst-case på <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4>
<p>En liste med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> elementer har <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> permutasjoner, som vi ved å sortere skal finne én bestemt av. Vi kan modellere problemet som et binært beslutningstre, med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> løvnoder. Høyden på treet blir antall beslutninger vi må gjøre, altså antall sammenligninger, for å komme til en løsning. Det totale antall noder i et komplett binærtre med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> løvnoder er <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo stretchy="false">!</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n!-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. Det maksimale antall løvnoder i et binærtre er <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>. Vi har da <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>≥</mo><mi>n</mi><mo stretchy="false">!</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>h</mi><mo>≥</mo><mi>lg</mi><mo>⁡</mo><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>h</mi><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^h \geq n! \implies h \geq \lg{n!} \implies h = \Omega(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.71844em;vertical-align:-0.024em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mclose">!</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<h4>[D2] Vite hva en stabil sorteringsalgoritme er</h4>
<p>En sorteringsalgoritme sies å være stabil dersom rekkefølgen av like elementer i listen som sorteres blir bevart.</p>
<h4>[D3] Forstå Counting-Sort, og hvorfor den er stabil</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Counting-Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme for heltall mellom <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></td>
</tr>
<tr>
<td>Input</td>
<td>A: liste av heltall mellom 0 og k, B: liste for resultatet, k: det høyeste tallet</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>False</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">counting_sort</span>(<span class="hljs-params">A, B, k</span>):
    C = [<span class="hljs-number">0</span>] * k
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> A:
        C[i] += <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k):
        C[i] += C[i-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        v = A[i]
        B[C[v]-<span class="hljs-number">1</span>] = v
        C[v] -= <span class="hljs-number">1</span>
</code></pre>
<p><a href="lib/counting_sort.py">Implementasjon av Counting-Sort</a></p>
<h4>[D4] Forstå Radix-Sort, og hvorfor den trenger en stabil subrutine</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Radix-Sort (using Counting-Sort)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme for elementer med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span> siffer, der hvert siffer er mellom <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></td>
</tr>
<tr>
<td>Input</td>
<td>A: liste som skal sorteres, B: liste for resultatet, k: det høyeste sifferet, d: antall siffer i hvert element</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(d(n + k))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>False</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
</tbody>
</table>
<p>Merk: følgende implementasjon sorterer strenger.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">counting_sort</span>(<span class="hljs-params">A, B, k, d</span>):
    C = [<span class="hljs-number">0</span>] * k
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> A:
        C[<span class="hljs-built_in">ord</span>(v[d])] += <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k):
        C[i] += C[i-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        v = A[i]
        B[C[<span class="hljs-built_in">ord</span>(v[d])]-<span class="hljs-number">1</span>] = v
        C[<span class="hljs-built_in">ord</span>(v[d])] -= <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">radix_sort</span>(<span class="hljs-params">A, d</span>):
    B = [<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(A)
    k = (<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">max</span>(c <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> A <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word)) + <span class="hljs-number">1</span>) \
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(A) <span class="hljs-keyword">and</span> d <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(d-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
        counting_sort(A, B, k, i)
        A, B = B, A
    <span class="hljs-keyword">return</span> A
</code></pre>
<p><a href="lib/radix_sort.py">Implementasjon av Radix-Sort</a></p>
<h4>[D5] Forstå Bucket-Sort</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Bucket-Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme for tall mellom 0 og 1</td>
</tr>
<tr>
<td>Input</td>
<td>A: liste av tall mellom 0 og 1</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, hvis mange elementer havner i samme bøtte</td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>False</td>
</tr>
<tr>
<td>Stabil</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bucket_sort</span>(<span class="hljs-params">A</span>):
    n = <span class="hljs-built_in">len</span>(A)
    B = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        B[floor(n * A[i])].append(A[i])
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        insertion_sort(B[j])
    <span class="hljs-keyword">return</span> [value <span class="hljs-keyword">for</span> bucket <span class="hljs-keyword">in</span> B <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> bucket]
</code></pre>
<p><a href="lib/bucket_sort.py">Implementasjon av Bucket-Sort</a></p>
<h4>[D6] Forstå Randomized-Select</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Randomized-Select</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner det <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>-te minste elementet i arrayet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>p</mi><mo>…</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[p \dots r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></td>
</tr>
<tr>
<td>Input</td>
<td>A: liste av tall, p: minste indeks, r: største indeks, i: ordningstallet</td>
</tr>
<tr>
<td>Output</td>
<td>Det <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>-te minste elementet</td>
</tr>
<tr>
<td>Worst case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Average case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Best case</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">randomized_select</span>(<span class="hljs-params">A, p, r, i</span>):
    <span class="hljs-keyword">if</span> p == r:
        <span class="hljs-keyword">return</span> A[p]
    q = randomized_partition(A,p,r)
    k = q - p + <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> i == k:
        <span class="hljs-keyword">return</span> A[q]
    <span class="hljs-keyword">elif</span> i &lt; k:
        <span class="hljs-keyword">return</span> randomized_select(A, p, q - <span class="hljs-number">1</span>, i)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> randomized_select(A, q + <span class="hljs-number">1</span>, r, i - k)
</code></pre>
<p><a href="lib/randomized_select.py">Implementasjon av Randomized-Select</a></p>
<h4>[D7] Kjenne til Select</h4>
<p>Select løser det samme problemet som Randomized-Select, men prøver å velge en god pivot istedenfor å ta en tilfeldig.
Merk: Det kreves ikke grundig forståelse av virkemåten til Select.</p>
<h3>Forelesning 5: Rotfaste trestrukturer</h3>
<h4>[E1] Forstå hvordan heaps fungerer, og hvordan de kan brukes som prioritetskøer</h4>
<p>Max-Heap kan brukes som en prioritetskø som prioriterer de største elementene, Min-Heap kan brukes som en prioritetskø som prioriterer de minste elementene.</p>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner indeksen til forelderen til en node i en binærhaug</td>
</tr>
<tr>
<td>Input</td>
<td>i: indeksen til en node</td>
</tr>
<tr>
<td>Output</td>
<td>Indeksen til forelderen</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Left</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner det venstre barnet til en node i en binærhaug</td>
</tr>
<tr>
<td>Input</td>
<td>i: indeksen til en node</td>
</tr>
<tr>
<td>Output</td>
<td>Indeksen til det venstre barnet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner det høyre barnet til en node i en binærhaug</td>
</tr>
<tr>
<td>Input</td>
<td>i: indeksen til en node</td>
</tr>
<tr>
<td>Output</td>
<td>Indeksen til det høyre barnet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h5>Heap</h5>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params">i</span>):
    <span class="hljs-keyword">return</span> floor(i / <span class="hljs-number">2</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">i</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> <span class="hljs-comment"># 2 * i, if 1-indexed</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">right</span>(<span class="hljs-params">i</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 2 * i + 1, if 1-indexed</span>
</code></pre>
<h5>Max-Heap</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Max-Heapify</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Realiserer maks-haug-egenskapen for en gitt node i en maks-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: maks-haug i: indeksen til en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Build-Max-Heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bygger en maks-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: array</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Maximum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returnerer det maksimale elementet i en maks-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: maks-haug</td>
</tr>
<tr>
<td>Output</td>
<td>Det maksimale elementet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Extract-Maximum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjerner og returnerer det maksimale elementet i en maks-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: maks-haug</td>
</tr>
<tr>
<td>Output</td>
<td>Det maksimale elementet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Increase-Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter nøkkelen til en node til en ny (høyere) verdi</td>
</tr>
<tr>
<td>Input</td>
<td>A: maks-haug, i: indeks, key: den nye nøkkelen</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Max-Heap-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter inn et nytt element i en maks-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: maks-haug, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">max_heapify</span>(<span class="hljs-params">A, i</span>):
    l = left(i)
    r = right(i)
    <span class="hljs-keyword">if</span> l &lt; A.heap_size <span class="hljs-keyword">and</span> A[l] &gt; A[i]:
        largest = l
    <span class="hljs-keyword">else</span>:
        largest = i
    <span class="hljs-keyword">if</span> r &lt; A.heap_size <span class="hljs-keyword">and</span> A[r] &gt; A[largest]:
        largest = r
    <span class="hljs-keyword">if</span> largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">build_max_heap</span>(<span class="hljs-params">A</span>):
    A.heap_size = <span class="hljs-built_in">len</span>(A)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(<span class="hljs-built_in">len</span>(A) / <span class="hljs-number">2</span>), -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        max_heapify(A, i)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_maximum</span>(<span class="hljs-params">A</span>):
    <span class="hljs-keyword">return</span> A[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_extract_max</span>(<span class="hljs-params">A</span>):
    <span class="hljs-keyword">if</span> A.heap_size &lt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR: heap underflow"</span>)
    max_ = A[<span class="hljs-number">0</span>]
    A[<span class="hljs-number">0</span>] = A[A.heap_size - <span class="hljs-number">1</span>]
    A.heap_size -= <span class="hljs-number">1</span>
    max_heapify(A, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> max_

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_increase_key</span>(<span class="hljs-params">A, i, key</span>):
    <span class="hljs-keyword">if</span> key &lt; A[i]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR: new key is smaller than current key"</span>)
    A[i] = key
    <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[parent(i)] &lt; A[i]:
        A[i], A[parent(i)] = A[parent(i)], A[i]
        i = parent(i)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">max_heap_insert</span>(<span class="hljs-params">A, key</span>):
    A.heap_size += <span class="hljs-number">1</span>
    A[A.heap_size - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    heap_increase_key(A, A.heap_size - <span class="hljs-number">1</span>, key)
</code></pre>
<h5>Min-Heap</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Min-Heapify</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Realiserer min-haug-egenskapen for en gitt node i en min-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: min-haug i: indeksen til en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Build-Min-Heap</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bygger en min-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: array</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Minimum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returnerer det minimale elementet i en min-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: min-haug</td>
</tr>
<tr>
<td>Output</td>
<td>Det minimale elementet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Extract-Minimum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Fjerner og returnerer det minimale elementet i en min-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: min-haug</td>
</tr>
<tr>
<td>Output</td>
<td>Det minimale elementet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heap-Increase-Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter nøkkelen til en node til en ny (høyere) verdi</td>
</tr>
<tr>
<td>Input</td>
<td>A: min-haug, i: indeks, key: den nye nøkkelen</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Min-Heap-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Setter inn et nytt element i en min-haug</td>
</tr>
<tr>
<td>Input</td>
<td>A: min-haug, x: element</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">min_heapify</span>(<span class="hljs-params">A, i</span>):
    l = left(i)
    r = right(i)
    <span class="hljs-keyword">if</span> l &lt; A.heap_size <span class="hljs-keyword">and</span> A[l] &lt; A[i]:
        smallest = l
    <span class="hljs-keyword">else</span>:
        smallest = i
    <span class="hljs-keyword">if</span> r &lt; A.heap_size <span class="hljs-keyword">and</span> A[r] &lt; A[smallest]:
        smallest = r
    <span class="hljs-keyword">if</span> smallest != i:
        A[i], A[smallest] = A[smallest], A[i]
        min_heapify(A, smallest)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">build_min_heap</span>(<span class="hljs-params">A</span>):
    A.heap_size = <span class="hljs-built_in">len</span>(A)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(floor(<span class="hljs-built_in">len</span>(A) / <span class="hljs-number">2</span>), -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):
        min_heapify(A, i)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_minimum</span>(<span class="hljs-params">A</span>):
    <span class="hljs-keyword">return</span> A[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_extract_min</span>(<span class="hljs-params">A</span>):
    <span class="hljs-keyword">if</span> A.heap_size &lt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR: heap underflow"</span>)
    min_ = A[<span class="hljs-number">0</span>]
    A[<span class="hljs-number">0</span>] = A[A.heap_size - <span class="hljs-number">1</span>]
    A.heap_size -= <span class="hljs-number">1</span>
    min_heapify(A, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> min_

<span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_decrease_key</span>(<span class="hljs-params">A, i, key</span>):
    <span class="hljs-keyword">if</span> A[i] &lt; key:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR: new key is larger than current key"</span>)
    A[i] = key
    <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> A[i] &lt; A[parent(i)]:
        A[i], A[parent(i)] = A[parent(i)], A[i]
        i = parent(i)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">min_heap_insert</span>(<span class="hljs-params">A, key</span>):
    A.heap_size += <span class="hljs-number">1</span>
    A[A.heap_size - <span class="hljs-number">1</span>] = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    heap_decrease_key(A, A.heap_size - <span class="hljs-number">1</span>, key)
</code></pre>
<p><a href="lib/structures/binary_heap.py">Implementasjon av heaps</a></p>
<h4>[E2] Forstå Heapsort</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Heapsort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorteringsalgoritme</td>
</tr>
<tr>
<td>Input</td>
<td>A: vilkårlig liste av tall</td>
</tr>
<tr>
<td>Output</td>
<td>Sortert liste (in place)</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>In place</td>
<td>True</td>
</tr>
<tr>
<td>Stabil</td>
<td>False</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapsort</span>(<span class="hljs-params">A</span>):
    build_max_heap(A)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):
        A[<span class="hljs-number">0</span>], A[i] = A[i], A[<span class="hljs-number">0</span>]
        A.heap_size -= <span class="hljs-number">1</span>
        max_heapify(A, <span class="hljs-number">0</span>)
</code></pre>
<p><a href="lib/heapsort.py">Implementasjon av Heapsort</a></p>
<h4>[E3] Forstå hvordan rotfaste trær kan implementeres</h4>
<p>Binærtrær kan representeres ved at hver node har tre pekere: p (parent), left og right.
For trær hvor node kan ha flere barn, kan man også representere det ved tre pekere: p, left-child og right-sibling.</p>
<h4>[E4] Forstå hvordan binære søketrær fungerer</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Inorder-Tree-Walk</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Printer et binærsøketre <em>inorder</em></td>
</tr>
<tr>
<td>Input</td>
<td>x: noden å begynne på (gjerne rotnoden)</td>
</tr>
<tr>
<td>Output</td>
<td>Utskrift av nodene i rekkefølge</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Søker etter et node med en gitt nøkkel</td>
</tr>
<tr>
<td>Input</td>
<td>x: noden å begynne på (gjerne rotnoden), k: nøkkelen det søkes etter</td>
</tr>
<tr>
<td>Output</td>
<td>Noden med nøkkelen, eller NIL</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Minimum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returnerer den minste noden i binærsøketreet</td>
</tr>
<tr>
<td>Input</td>
<td>x: noden å begynne på (gjerne rotnoden)</td>
</tr>
<tr>
<td>Output</td>
<td>Den minste noden</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Maximum</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returnerer den største noden i binærsøketreet</td>
</tr>
<tr>
<td>Input</td>
<td>x: noden å begynne på (gjerne rotnoden)</td>
</tr>
<tr>
<td>Output</td>
<td>Den største noden</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Successor</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returnerer noden som er etter den gitt noden, når de er i <em>inorder</em> rekkefølge</td>
</tr>
<tr>
<td>Input</td>
<td>x: en node</td>
</tr>
<tr>
<td>Output</td>
<td><em>Successor</em>-en til den gitte noden</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Insert</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Legger til en node til treet, på en gyldig plass</td>
</tr>
<tr>
<td>Input</td>
<td>T: treet (rotnoden), z: noden som legges til</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Transplant</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Erstatter en node i treet med en annen</td>
</tr>
<tr>
<td>Input</td>
<td>T: treet (rotnoden), u: noden som skal erstattes, v: noden som erstatter</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Tree-Delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sletter den gitte noden fra treet</td>
</tr>
<tr>
<td>Input</td>
<td>x: en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder_tree_walk</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">if</span> x != <span class="hljs-literal">None</span>:
        inorder_tree_walk(x.left)
        <span class="hljs-built_in">print</span>(x.key)
        inorder_tree_walk(x.right)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_search</span>(<span class="hljs-params">x, k</span>):
    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> k == x.key:
        <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">if</span> k &lt; x.key:
        <span class="hljs-keyword">return</span> tree_search(x.left, k)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> tree_search(x.right, k)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative_tree_search</span>(<span class="hljs-params">x, k</span>):
    <span class="hljs-keyword">while</span> x != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> k != x.key:
        <span class="hljs-keyword">if</span> k &lt; x.key:
            x = x.left
        <span class="hljs-keyword">else</span>:
            x = x.right
    <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_minimum</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">while</span> x.left != <span class="hljs-literal">None</span>:
        x = x.left
    <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_maximum</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">while</span> x.right != <span class="hljs-literal">None</span>:
        x = x.right
    <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_successor</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">if</span> x.right != <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> tree_minimum(x.right)
    y = x.p
    <span class="hljs-keyword">while</span> y != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> x == y.right:
        x = y
        y = y.p
    <span class="hljs-keyword">return</span> y

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_insert</span>(<span class="hljs-params">T, z</span>):
    y = <span class="hljs-literal">None</span>
    x = T.root
    <span class="hljs-keyword">while</span> x != <span class="hljs-literal">None</span>:
        y = x
        <span class="hljs-keyword">if</span> z.key &lt; x.key:
            x = x.left
        <span class="hljs-keyword">else</span>:
            x = x.right
    z.p = y
    <span class="hljs-keyword">if</span> y == <span class="hljs-literal">None</span>:
        T.root = z
    <span class="hljs-keyword">elif</span> z.key &lt; y.key:
        y.left = z
    <span class="hljs-keyword">else</span>:
        y.right = z

<span class="hljs-keyword">def</span> <span class="hljs-title function_">transplant</span>(<span class="hljs-params">T, u, v</span>):
    <span class="hljs-keyword">if</span> u.p == <span class="hljs-literal">None</span>:
        T.root = v
    <span class="hljs-keyword">elif</span> u == u.p.left:
        u.p.left = v
    <span class="hljs-keyword">else</span>:
        u.p.right = v
    <span class="hljs-keyword">if</span> v != <span class="hljs-literal">None</span>:
        v.p = u.p

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_delete</span>(<span class="hljs-params">T, z</span>):
    <span class="hljs-keyword">if</span> z.left == <span class="hljs-literal">None</span>:
        transplant(T, z, z.right)
    <span class="hljs-keyword">elif</span> z.right == <span class="hljs-literal">None</span>:
        transplant(T, z, z.left)
    <span class="hljs-keyword">else</span>:
        y = tree_minimum(z.right)
        <span class="hljs-keyword">if</span> y.p != z:
            transplant(T, y, y.right)
            y.right = z.right
            y.right.p = y
        transplant(T, z, y)
        y.left = z.left
        y.left.p = y
</code></pre>
<p><a href="lib/structures/binary_tree.py">Implementasjon av binære søketrær</a></p>
<h4>[E5] Vite at forventet høyde for et tilfeldig binært søketre er <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4>
<p>Dette er bevist i boka på side 300, men det er ikke nødvendig å forstå beviset.</p>
<h4>[E6] Vite at det finnes søketrær med garantert høyde på <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h4>
<p>Trivielt?</p>
<h3>Forelesning 6: Dynamisk programmering</h3>
<h4>[F1] Forstå ideen om en delinstansgraf</h4>
<p>En delinstansgraf viser hvordan en probleminstans kan bygges opp av delinstanser.</p>
<h4>[F2] Forstå designmetoden dynamisk programmering</h4>
<p>When developing a dynamic-programming algorithm, we follow a sequence of four steps:</p>
<ol>
<li>Characterize the structure of an optimal solution.</li>
<li>Recursively define the value of an optimal solution.</li>
<li>Compute the value of an optimal solution, typically in a bottom-up fashion.</li>
<li>Construct an optimal solution from computed information.</li>
</ol>
<p>Dynamisk programmering brukes for problemer som har overlappende delproblemer og optimal delstruktur.</p>
<h4>[F3] Forstå løsning ved memoisering (top-down)</h4>
<p>Ved memoisering løser vi problemet på vanlig rekursiv måte, men lagrer resultatet av hvert delproblem, slik at det kan brukes senere uten ytterligere kjøretid.</p>
<h4>[F4] Forstå løsning ved iterasjon (bottom-up)</h4>
<p>Vi sorterer delproblemene etter størrelse. Vi begynner med det minste og bygger oss opp til en løsning av det større problemet.</p>
<h4>[F5] Forstå hvordan man rekonstruerer en løsning fra lagrede beslutninger</h4>
<p>Sjekke om det er blitt gjort tidligere og hente resultatet istedenfor å kalkulere det på nytt.</p>
<h4>[F6] Forstå hva optimal delstruktur er</h4>
<p>Optimal delstruktur vil si at en løsning av en delinstans inngår i den globale løsningen.</p>
<h4>[F7] Forstå hva overlappende delinstanser er</h4>
<p>Hvis to delinstanser i en delinstans begge avhenger av en tredje delinstans, er den tredje delinstansen en overlappende delinstans.</p>
<h4>[F8] Forstå eksemplene stavkutting og LCS</h4>
<h5>Stavkutting</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Cut-Rod</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner beste pris, gitt en stavlengde og priser på ulike lengder</td>
</tr>
<tr>
<td>Input</td>
<td>p: tabell av priser, n: stavlengde</td>
</tr>
<tr>
<td>Output</td>
<td>Beste pris</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Memoized-Cut-Rod</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Memoisert (top-down) versjon av Cut-Rod</td>
</tr>
<tr>
<td>Input</td>
<td>p: tabell av priser, n: stavlengde</td>
</tr>
<tr>
<td>Output</td>
<td>Beste pris</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Bottom-Up-Cut-Rod</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Iterativ (bottom-up) versjon av Cut-Rod</td>
</tr>
<tr>
<td>Input</td>
<td>p: tabell av priser, n: stavlengde</td>
</tr>
<tr>
<td>Output</td>
<td>Beste pris</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cut_rod</span>(<span class="hljs-params">p, n</span>):
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    q = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        q = <span class="hljs-built_in">max</span>(q, p[i - <span class="hljs-number">1</span>] + cut_rod(p, n - i))
    <span class="hljs-keyword">return</span> q

<span class="hljs-keyword">def</span> <span class="hljs-title function_">memoized_cut_rod</span>(<span class="hljs-params">p, n</span>):
    r = [-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * (n + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> memoized_cut_rod_aux(p, n, r)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">memoized_cut_rod_aux</span>(<span class="hljs-params">p, n, r</span>):
    <span class="hljs-keyword">if</span> r[n - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> r[n - <span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        q = <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span>:
        q = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            q = <span class="hljs-built_in">max</span>(q, p[i - <span class="hljs-number">1</span>] + memoized_cut_rod_aux(p, n - i))
    r[n] = q
    <span class="hljs-keyword">return</span> q

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bottom_up_cut_rod</span>(<span class="hljs-params">p, n</span>):
    r = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        q = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>):
            q = <span class="hljs-built_in">max</span>(q, p[i] + r[j - i])
        r[j] = q
    <span class="hljs-keyword">return</span> r[n]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">extended_bottom_up_cut_rod</span>(<span class="hljs-params">p, n</span>):
    r = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    s = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        q = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> q &lt; p[i] + r[j - i]:
                q = p[i] + r[j - i]
                s[j] = i
        r[j] = q
    <span class="hljs-keyword">return</span> r, s

<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_cut_rod_solution</span>(<span class="hljs-params">p, n</span>):
    _, s = extended_bottom_up_cut_rod(p, n)
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(s[n])
        n -= s[n]
</code></pre>
<p><a href="lib/cut_rod.py">Implementasjon av stavkutting</a></p>
<h5>Longest common subsequence (LCS)</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>LCS-Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sammenligner liste X og Y og finner lengste felles subsekvens</td>
</tr>
<tr>
<td>Input</td>
<td>X: liste, Y: liste</td>
</tr>
<tr>
<td>Output</td>
<td>To matriser som lengste felles subsekvens kan leses fra (brukes i Print-LCS)</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Print-LCS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Printer lengste felles subsekvens, gitt b-matrisen fra LCS-Length</td>
</tr>
<tr>
<td>Input</td>
<td>b: matrise fra LCS-Length, X: den tilhørende listen som ble brukt i LCS-Length, i: hvilken rad det skal leses fra, j: hvilken kolonne det skal leses fra</td>
</tr>
<tr>
<td>Output</td>
<td>Lengste felles subsekvens</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Minnebruk</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcs_length</span>(<span class="hljs-params">X, Y</span>):
    m = <span class="hljs-built_in">len</span>(X)
    n = <span class="hljs-built_in">len</span>(Y)
    b = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]
    c = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>)]

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> X[i - <span class="hljs-number">1</span>] == Y[j - <span class="hljs-number">1</span>]:
                c[i][j] = c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>
                b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;↖&#x27;</span>
            <span class="hljs-keyword">elif</span> c[i - <span class="hljs-number">1</span>][j] &gt;= c[i][j - <span class="hljs-number">1</span>]:
                c[i][j] = c[i - <span class="hljs-number">1</span>][j]
                b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;↑&#x27;</span>
            <span class="hljs-keyword">else</span>:
                c[i][j] = c[i][j - <span class="hljs-number">1</span>]
                b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;←&#x27;</span>
    <span class="hljs-keyword">return</span> c, b

<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_lcs</span>(<span class="hljs-params">b, X, i, j</span>):
    <span class="hljs-keyword">if</span> i == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == -<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">if</span> b[i][j] == <span class="hljs-string">&#x27;↖&#x27;</span>:
        print_lcs(b, X, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)
        <span class="hljs-built_in">print</span>(X[i], end=<span class="hljs-string">" "</span>)
    <span class="hljs-keyword">elif</span> b[i][j] == <span class="hljs-string">&#x27;↑&#x27;</span>:
        print_lcs(b, X, i - <span class="hljs-number">1</span>, j)
    <span class="hljs-keyword">else</span>:
        print_lcs(b, X, i, j - <span class="hljs-number">1</span>)
</code></pre>
<p><a href="lib/longest_common_subsequence.py">Implementasjon av LCS</a></p>
<h4>[F9] Forstå løsningen på det binære ryggsekkproblemet</h4>
<p>Se kompendium s. 93.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack</span>(<span class="hljs-params">n, W, w, v</span>):
    <span class="hljs-string">"""
    KNAPSACK

    Time Complexity: Theta(nW) = Theta(n2^m)
    """</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    x = knapsack(n - <span class="hljs-number">1</span>, W)
    <span class="hljs-keyword">if</span> w[n] &gt; W:
        <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">else</span>:
        y = knapsack(n - <span class="hljs-number">1</span>, W - w[n]) + v[n]
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(x, y)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">bottom_up_knapsack</span>(<span class="hljs-params">n, W, w, v</span>):
    <span class="hljs-string">"""
    KNAPSACK&#x27;

    Time Complexity: Theta(nW) = Theta(n2^m)
    """</span>
    K = [[<span class="hljs-number">0</span>] * (W + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W + <span class="hljs-number">1</span>):
            x = K[i - <span class="hljs-number">1</span>][j]
            <span class="hljs-keyword">if</span> j &lt; w[i]:
                K[i][j] = x
            <span class="hljs-keyword">else</span>:
                y = K[i - <span class="hljs-number">1</span>][j - w[i]] + v[i]
                K[i][j] = <span class="hljs-built_in">max</span>(x, y)
</code></pre>
<p><a href="lib/knapsack.py">Implementasjon av det binære ryggsekkproblemet</a></p>
<h3>Forelesning 7: Grådige algoritmer</h3>
<h4>[G1] Forstå designmetoden grådighet</h4>
<p>A greedy algorithm always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally optimal solution.</p>
<ol>
<li>Cast the optimization problem as one in which we make a choice and are left
with one subproblem to solve.</li>
<li>Prove that there is always an optimal solution to the original problem that makes
the greedy choice, so that the greedy choice is always safe.</li>
<li>Demonstrate optimal substructure by showing that, having made the greedy
choice, what remains is a subproblem with the property that if we combine an
optimal solution to the subproblem with the greedy choice we have made, we
arrive at an optimal solution to the original problem.</li>
</ol>
<h4>[G2] Forstå grådighetsegenskapen (the greedy-choice property)</h4>
<p><strong>Greedy-choice property</strong>: we can assemble a globally
optimal solution by making locally optimal (greedy) choices.</p>
<h4>[G3] Forstå eksemplene aktivitet-utvelgelse og det kontinuerlige ryggsekkproblemet</h4>
<h5>Aktivitet-utvelgelse</h5>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Recursive-Activity-Selector</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Maksimerer antall aktiviterer</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">s</span></code>: starttider, <code><span class="hljs-attribute">f</span></code>: sluttider, <code><span class="hljs-attribute">k</span></code>: tid, <code><span class="hljs-attribute">n</span></code>: antall aktiviteter å velge mellom</td>
</tr>
<tr>
<td>Output</td>
<td>Et sett av de valgte aktivitene</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Ekstra krav</td>
<td>En fake aktivitet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> må legges til s og f. Input må være sortert etter sluttider.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Greedy-Activity-Selector</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Maksimerer antall aktiviterer</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">s</span></code>: starttider, <code><span class="hljs-attribute">f</span></code>: sluttider</td>
</tr>
<tr>
<td>Output</td>
<td>Et sett av de valgte aktivitene</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>Ekstra krav</td>
<td>En fake aktivitet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> med <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> må legges til s og f. Input må være sortert etter sluttider.</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive_activity_selector</span>(<span class="hljs-params">s, f, k, n</span>):
    m = k + <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> m &lt;= n <span class="hljs-keyword">and</span> s[m] &lt; f[k]:
        m += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> m &lt;= n:
        <span class="hljs-keyword">return</span> {m}.union(recursive_activity_selector(s, f, m, n)) <span class="hljs-comment"># a[m]</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">set</span>()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">greedy_activity_selector</span>(<span class="hljs-params">s, f</span>):
    n = <span class="hljs-built_in">len</span>(s)
    A = <span class="hljs-built_in">set</span>(s[<span class="hljs-number">0</span>])
    k = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):
        <span class="hljs-keyword">if</span> s[m] &gt;= f[k]:
            A.add(m) <span class="hljs-comment"># a[m]</span>
            k = m
    <span class="hljs-keyword">return</span> A
</code></pre>
<h5>Det kontinuerlige ryggsekkproblemet</h5>
<p>I motsetning til det binære ryggsekkproblemet, er det kontinuerlige ryggsekkproblemet enkelt å løse med en grådig algoritme. Vi kan alltid fylle ryggsekken med det mest verdifulle, helt til ryggsekken er full.</p>
<h4>[G4] Forstå Huffman og Huffman-koder</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Huffman</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bygger et Huffman-tre (vha. min-haug)</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">C</span></code>: et sett av <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> karakterer, hver med en bestemt frekvens <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">c.freq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</td>
</tr>
<tr>
<td>Output</td>
<td>Roten til Huffman-treet</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">huffman</span>(<span class="hljs-params">C</span>):
    n = <span class="hljs-built_in">len</span>(C)
    Q = build_min_heap(C)
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):
        z = Node()
        x = heap_extract_min(Q)
        y = heap_extract_min(Q)
        z.left = x
        z.right = y
        z.freq = x.freq + y.freq
        min_heap_insert(Q, z)
    <span class="hljs-keyword">return</span> heap_extract_min(Q)
</code></pre>
<p><a href="lib/huffman.py">Implementasjon av Huffman</a></p>
<h3>Forelesning 8: Traversering av grafer</h3>
<h4>[H1] Forstå hvordan grafer kan implementeres</h4>
<p>To vanlige implementasjoner av grafer er 1. å bruke nabolister, eller 2. en nabomatrise. Nabolister er effektive for grafer med få kanter, mens nabomatriser er effektive for grafer med mange kanter.</p>
<h4>[H2] Forstå BFS, også for å finne korteste vei uten vekter</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>BFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bredde først søk, kan finne korteste vei uten vekter</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">s</span></code> startnode</td>
</tr>
<tr>
<td>Output</td>
<td>Markerer alle noder med avstand <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span> fra startnoden, og forgjenger <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span></td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">G, s</span>):
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V - <span class="hljs-built_in">set</span>(s):
        u.color = <span class="hljs-string">"white"</span>
        u.d = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        u.pi = <span class="hljs-literal">None</span>
    s.color = <span class="hljs-string">"gray"</span>
    s.d = <span class="hljs-number">0</span>
    s.pi = <span class="hljs-literal">None</span>
    Q = Queue()
    enqueue(Q, s)
    <span class="hljs-keyword">while</span> Q:
        u = dequeue(Q)
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u]:
            <span class="hljs-keyword">if</span> v.color == <span class="hljs-string">"white"</span>:
                v.color = <span class="hljs-string">"gray"</span>
                v.d = u.d + <span class="hljs-number">1</span>
                v.pi = u
                enqueue(Q, v)
        u.color = <span class="hljs-string">"black"</span>
</code></pre>
<p><a href="lib/bfs.py">Implementasjon av BFS</a></p>
<h4>[H3] Forstå DFS, parentesteoremet og hvit-sti-teoremet</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Dybde først søk, kan brukes til å klassifisere kanter</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf</td>
</tr>
<tr>
<td>Output</td>
<td>Markerer alle noder med tid <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">time</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span>, og forgjenger <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span></td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">G</span>):
    <span class="hljs-keyword">global</span> time
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V:
        u.color == <span class="hljs-string">"white"</span>
        u.pi = <span class="hljs-literal">None</span>
    time = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V:
        <span class="hljs-keyword">if</span> u.color == <span class="hljs-string">"white"</span>:
            dfs_visit(G, u)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_visit</span>(<span class="hljs-params">G, u</span>):
    <span class="hljs-keyword">global</span> time
    time += <span class="hljs-number">1</span>
    u.d = time
    u.color = <span class="hljs-string">"gray"</span>
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u]:
        <span class="hljs-keyword">if</span> v.color == <span class="hljs-string">"white"</span>:
            v.pi = u
            dfs_visit(G, v)
    u.color = <span class="hljs-string">"black"</span>
    time += <span class="hljs-number">1</span>
    u.f = time
</code></pre>
<p><a href="lib/dfs.py">Implementasjon av DFS</a>
Se kompendium s. 109.</p>
<h4>[H4] Forstå hvordan DFS klassifiserer kanter</h4>
<p>Se kompendium s. 110.</p>
<h4>[H5] Forstå Topological-Sort</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Topological-Sort</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Sorterer en graf topologisk, vha. DFS</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf</td>
</tr>
<tr>
<td>Output</td>
<td>En topologisk sortert lenket liste over nodene</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">topological_sort</span>(<span class="hljs-params">G</span>):
    <span class="hljs-keyword">global</span> L
    L = LinkedList()
    ts_dfs(G)
    <span class="hljs-keyword">return</span> L

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ts_dfs</span>(<span class="hljs-params">G</span>):
    <span class="hljs-keyword">global</span> time
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V:
        u.color == <span class="hljs-string">"white"</span>
        u.pi = <span class="hljs-literal">None</span>
    time = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V:
        <span class="hljs-keyword">if</span> u.color == <span class="hljs-string">"white"</span>:
            ts_dfs_visit(G, u)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">ts_dfs_visit</span>(<span class="hljs-params">G, u</span>):
    <span class="hljs-keyword">global</span> time, L
    time += <span class="hljs-number">1</span>
    u.d = time
    u.color = <span class="hljs-string">"gray"</span>
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u]:
        <span class="hljs-keyword">if</span> v.color == <span class="hljs-string">"white"</span>:
            v.pi = u
            ts_dfs_visit(G, v)
    u.color = <span class="hljs-string">"black"</span>
    time += <span class="hljs-number">1</span>
    u.f = time
    list_insert(L, LinkedListElement(u))
</code></pre>
<p><a href="lib/topological_sort.py">Implementasjon av Topological-Sort</a></p>
<h4>[H6] Forstå hvordan DFS kan implementeres med en stakk</h4>
<p>Hvis du bytter ut køen i implementasjonen av BFS med en stakk, vil det bli DFS.</p>
<h4>[H7] Forstå hva traverseringstrær (som bredde-først- og dybde-først-trær) er</h4>
<p>Trær som er resultater av henholdsvis BFS og DFS.</p>
<h4>[H8] Forstå traversering med vilkårlig prioritetskø</h4>
<p>Se implementasjon av BFS, denne har FIFO-kø men virker annerledes ved bruk av annen kø.</p>
<h3>Forelesning 9: Minimale spenntrær</h3>
<p>The inverse Ackermann function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> grows extraordinarily slowly, so this factor is 4 or less for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> that can actually be written in the physical universe. This makes disjoint-set operations practically amortized constant time.</p>
<h4>[I1] Forstå skog-implementasjonen av disjunkte mengder</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Connected-Components</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Forbereder bruk av Same-Component</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>E</mi><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(E\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Same-Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Avgjør om to noder er i den samme komponenten</td>
</tr>
<tr>
<td>Input</td>
<td></td>
</tr>
<tr>
<td>Output</td>
<td>True hvis nodene er i samme komponent, False ellers</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Make-Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Lager et nytt sett bestående av den gitte noden</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">x</span></code>: en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Kobler sammen to noder, basert på rank</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">x</span></code>: en node, <code><span class="hljs-attribute">y</span></code>: en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Linker settet til <code><span class="hljs-attribute">x</span></code> med settet til <code><span class="hljs-attribute">y</span></code></td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">x</span></code>: en node, <code><span class="hljs-attribute">y</span></code>: en node</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Find-Set</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Returner den øverste forfederen til noden, og setter den som direkte forelder</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">x</span></code>: en node</td>
</tr>
<tr>
<td>Output</td>
<td>Den øverste forfederen til noden (representerer settet)</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">connected_components</span>(<span class="hljs-params">G</span>):
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.V:
        make_set(v)
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> G.E:
        <span class="hljs-keyword">if</span> find_set(u) != find_set(v):
            union(u, v)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">same_component</span>(<span class="hljs-params">u, v</span>):
    <span class="hljs-keyword">return</span> find_set(u) == find_set(v)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">make_set</span>(<span class="hljs-params">x</span>):
    x.p = x
    x.rank = <span class="hljs-number">0</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):
    link(find_set(x), find_set(y))

<span class="hljs-keyword">def</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">if</span> x.rank &gt; y.rank:
        y.p = x
    <span class="hljs-keyword">else</span>:
        x.p = y
        <span class="hljs-keyword">if</span> x.rank == y.rank:
            y.rank += <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_set</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">if</span> x != x.p:
        x.p = find_set(x.p)
    <span class="hljs-keyword">return</span> x.p
</code></pre>
<p><a href="lib/structures/disjunct_set.py">Implementasjon av disjunkte mengder</a></p>
<h4>[I2] Vite hva spenntrær og minimale spenntrær er</h4>
<p>Et <strong>tre</strong> er en urettet graf der alle noder er koblet med nøyaktig én sti. Dette er ekvivalent med å si at den er asyklisk. Et <strong>spenntre</strong> av en urettet graf <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> er en delgraf som er et tre og inneholder alle nodene i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>. Et <strong>minimalt spenntre</strong> er et spenntre hvor summen av kantvektene er minst mulig.</p>
<h4>[I3] Forstå Generic-MST</h4>
<pre><code class="hljs">GENERIC-MST(G, w):
    <span class="hljs-keyword">A</span> = Ø
    while <span class="hljs-keyword">A</span> does not form a spanning tree
        find an edge (u, v) that is safe for <span class="hljs-keyword">A</span>
        <span class="hljs-keyword">A</span> = <span class="hljs-keyword">A</span> U {(u, v)}
    return <span class="hljs-keyword">A</span>
</code></pre>
<h4>[I4] Forstå hvorfor lette kanter er trygge kanter</h4>
<p>Invariant: Kantmengden utgjør en del av et minimalt spenntre.
En <em>trygg kant</em> er en kant som bevarer invarianten.</p>
<p>Den letteste kanten (som ikke danner en sykel) er trygg fordi vi må uansett på et tidspunkt koble sammen snittet og det finnes ingen billigere måte å gjøre det lettere på. Kan illustreres med vei over bro https://algdat.idi.ntnu.no/lysark/forelesn09_kort.pdf</p>
<h4>[I5] Forstå MST-Kruskal</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>MST-Kruskal</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bygger et minimalt spenntre ved å sortere kantene</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene</td>
</tr>
<tr>
<td>Output</td>
<td>Kantene som danner et minimalt spenntre</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E \lg V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mst_kruskal</span>(<span class="hljs-params">G, w</span>):
    A = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.V:
        make_set(v)
    edges = <span class="hljs-built_in">sorted</span>(G.E, key=<span class="hljs-keyword">lambda</span> edge: w[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]])
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> edges:
        <span class="hljs-keyword">if</span> find_set(u) != find_set(v):
            A.add((u, v))
            union(u, v)
    <span class="hljs-keyword">return</span> A
</code></pre>
<p><a href="lib/minimal_spanning_tree.py">Implementasjon av MST-Kruskal</a></p>
<h4>[I6] Forstå MST-Prim</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>MST-Prim</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Bygger ett tre gradvis; en lett kant over snittet rundt treet er alltid trygg</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene, <code><span class="hljs-attribute">r</span></code>: rotnode</td>
</tr>
<tr>
<td>Output</td>
<td>Nodene sine forgjengerverdier <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span> danner et minimalt spenntre</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E \lg V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, eller <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E + V \lg V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> ved bruk av Fibonacci-haug</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mst_prim</span>(<span class="hljs-params">G, w, r</span>):
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G.V:
        u.key = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
        u.pi = <span class="hljs-literal">None</span>
    r.key = <span class="hljs-number">0</span>
    Q = build_min_heap(G.V)
    <span class="hljs-keyword">while</span> Q:
        u = heap_extract_min(Q)
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u]:
            <span class="hljs-keyword">if</span> v <span class="hljs-keyword">in</span> Q <span class="hljs-keyword">and</span> w[u][v] &lt; v.key:
                v.pi = u
                v.key = w[u][v]
</code></pre>
<p><a href="lib/minimal_spanning_tree.py">Implementasjon av MST-Prim</a></p>
<h3>Forelesning 10: Korteste vei fra én til alle</h3>
<h4>[J1] Forstå ulike varianter av korteste-vei-problemet</h4>
<p>Se kompendium s. 122.</p>
<h4>[J2] Forstå strukturen til korteste-vei-problemet</h4>
<p>Optimal delstruktur.</p>
<h4>[J3] Forstå at negative sykler gir mening for korteste enkle vei (simple path)</h4>
<p>For korteste enkle vei må man unngå syklene (for at den skal være enkel) så det tillatter at de kan eksistere i grafen.</p>
<h4>[J4] Forstå at korteste enkle vei kan løses vha. lengste enkle vei og omvendt</h4>
<p>Kan gå fra den ene til den andre ved å negere kantvektene.</p>
<h4>[J5] Forstå hvordan man kan representere et korteste-vei-tre</h4>
<p>Se kompendium s. 124.</p>
<h4>[J6] Forstå kant-slakking (edge relaxation) og Relax</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Relax</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> lar <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> være sin forelder, om det er gunstig</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">u</span></code>: en node, <code><span class="hljs-attribute">v</span></code>: en node, <code><span class="hljs-attribute">w</span></code>: kantvektene</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">relax</span>(<span class="hljs-params">u, v, w</span>):
    <span class="hljs-keyword">if</span> v.d &gt; u.d + w[u][v]:
        v.d = u.d + w[u][v]
        v.pi = u
</code></pre>
<p><a href="lib/single_source_shortest_path.py">Implementasjon av Relax</a></p>
<h4>[J7] Forstå ulike egenskaper ved korteste veier og slakking</h4>
<p>Se kompendium s. 125.</p>
<h4>[J8] Forstå Bellman-Ford</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Bellman-Ford</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner korteste vei fra én til alle</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene, <code><span class="hljs-attribute">s</span></code>: startnode</td>
</tr>
<tr>
<td>Output</td>
<td>Nodene sine <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>- og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span>-verdier antyder lengden fra start og forelder. Algoritmen returnerer False dersom det finnes en negativ sykel og True ellers</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellman_ford</span>(<span class="hljs-params">G, w, s</span>):
    initialize_single_source(G, s)
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(G.V) - <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> G.E:
            relax(u, v, w)
    <span class="hljs-keyword">for</span> u, v <span class="hljs-keyword">in</span> G.E:
        <span class="hljs-keyword">if</span> v.d &gt; u.d + w[u][v]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p><a href="lib/single_source_shortest_path.py">Implementasjon av Bellman-Ford</a></p>
<h4>[J9] Forstå Dag-Shortest-Paths</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>DAG-Shortest-Paths</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner korteste vei fra én til alle i en rettet asyklisk graf</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene, <code><span class="hljs-attribute">s</span></code>: startnode</td>
</tr>
<tr>
<td>Output</td>
<td>Nodene sine <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>- og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span>-verdier antyder lengden fra start og forelder</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dag_shortest_paths</span>(<span class="hljs-params">G, w, s</span>):
    initialize_single_source(G, s)
    u = topological_sort(G)
    <span class="hljs-keyword">while</span> u != <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u.key]:
            relax(u, v, w)
        u = u.<span class="hljs-built_in">next</span>
</code></pre>
<p><a href="lib/single_source_shortest_path.py">Implementasjon av Dag-Shortest-Paths</a></p>
<h4>[J10] Forstå kobling mellom Dag-Shortest-Paths og dynamisk programmering</h4>
<p>Dag-Shortest-Paths er en bottom-up løsning.</p>
<h4>[J11] Forstå Dijkstra</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Dijkstra</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner korteste vei fra én til alle i en graf med ikke-negative kantvekter</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene, <code><span class="hljs-attribute">s</span></code>: startnode</td>
</tr>
<tr>
<td>Output</td>
<td>Nodene sine <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>- og <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span></span></span></span>-verdier antyder lengden fra start og forelder</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E \lg V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, eller <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V \lg V + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ved bruk av Fibonacci-haug</td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">G, w, s</span>):
    initialize_single_source(G, s)
    S = <span class="hljs-built_in">set</span>()
    Q = build_min_heap(G.V.copy())
    <span class="hljs-keyword">while</span> Q:
        u = heap_extract_min(Q)
        S.add(u)
        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G.Adj[u]:
            relax(u, v, w)
</code></pre>
<p><a href="lib/single_source_shortest_path.py">Implementasjon av Dijkstra</a></p>
<h3>Forelesning 11: Korteste vei fra alle til alle</h3>
<h4>[K1] Forstå forgjengerstrukturen for alle-til-alle-varianten av korteste vei-problemet</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\pi_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> er forgjengeren til <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> i korteste vei fra <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> til <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</p>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Print-All-Pairs-Shortest-Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Printer korteste vei fra <code><span class="hljs-selector-tag">i</span></code> til <code><span class="hljs-attribute">j</span></code></td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-literal">Pi</span></code> forgjengermatrise, <code><span class="hljs-selector-tag">i</span></code>: nodeindeks, <code><span class="hljs-attribute">j</span></code>; nodeindeks</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_all_pairs_shortest_path</span>(<span class="hljs-params">Pi, i, j</span>):
    <span class="hljs-keyword">if</span> i == j:
        <span class="hljs-built_in">print</span>(i)
    <span class="hljs-keyword">elif</span> Pi[i][j] == <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"No path from <span class="hljs-subst">{i}</span> to <span class="hljs-subst">{j}</span> exists."</span>)
    <span class="hljs-keyword">else</span>:
        print_all_pairs_shortest_path(Pi, i, Pi[i][j])
        <span class="hljs-built_in">print</span>(j)
</code></pre>
<p><a href="lib/all_pairs_shortest_paths.py">Implementasjon av Print-All-Pairs-Shortest-Path</a></p>
<h4>[K2] Forstå Floyd-Warshall</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Floyd-Warshall</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner korteste vei fra alle til alle</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">W</span></code>: nabomatrise</td>
</tr>
<tr>
<td>Output</td>
<td>Avstandsmatrise</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(V^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd_warshall</span>(<span class="hljs-params">W</span>):
    n = <span class="hljs-built_in">len</span>(W)
    D = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)
    D[<span class="hljs-number">0</span>] = W
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        D[k] = [[<span class="hljs-literal">None</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                D[k][i][j] = <span class="hljs-built_in">min</span>(D[k - <span class="hljs-number">1</span>][i][j], \
                    D[k - <span class="hljs-number">1</span>][i][k] + D[k - <span class="hljs-number">1</span>][k][j])
    <span class="hljs-keyword">return</span> D[n]
</code></pre>
<p><a href="lib/all_pairs_shortest_paths.py">Implementasjon av Floyd-Warshall</a></p>
<h4>[K3] Forstå Transitive-Closure</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Transitive-Closure</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner transitiv lukning. Dvs. oversikt over hvilke noder som har stier til andre noder</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">W</span></code>: nabomatrise</td>
</tr>
<tr>
<td>Output</td>
<td>Matrise som beskriver den transitive lukningen ("binær avstandsmatrise")</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transitive_closure</span>(<span class="hljs-params">G</span>):
    n = <span class="hljs-built_in">len</span>(G.V)
    T = [<span class="hljs-literal">None</span>] * (n + <span class="hljs-number">1</span>)
    T[<span class="hljs-number">0</span>] = [[<span class="hljs-literal">None</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">or</span> (i, j) <span class="hljs-keyword">in</span> G.E:
                T[<span class="hljs-number">0</span>][i][j] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                T[<span class="hljs-number">0</span>][i][j] = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        T[k] = [[<span class="hljs-literal">None</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                T[k][i][j] = T[k - <span class="hljs-number">1</span>][i][j] <span class="hljs-keyword">or</span> T[k - <span class="hljs-number">1</span>][i][k] <span class="hljs-keyword">and</span> T[k - <span class="hljs-number">1</span>][k][j]
    <span class="hljs-keyword">return</span> T[n]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">transitive_closure_optimized</span>(<span class="hljs-params">G</span>):
    n = <span class="hljs-built_in">len</span>(G.V)
    T = [[<span class="hljs-literal">None</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">or</span> (i, j) <span class="hljs-keyword">in</span> G.E:
                T[i][j] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                T[i][j] = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
                T[i][j] = T[i][j] <span class="hljs-keyword">or</span> T[i][k] <span class="hljs-keyword">and</span> T[k][j]
    <span class="hljs-keyword">return</span> T
</code></pre>
<p><a href="lib/transitive_closure.py">Implementasjon av Transitive-Closure</a></p>
<h4>[K4] Forstå Johnson</h4>
<p>Se boka s. 700.</p>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Johnson</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Finner korteste vei fra alle til alle ved hjelp av <em>reweighting</em>, <em>Bellman-Ford</em> og <em>Dijkstra</em>.</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">w</span></code>: kantvektene</td>
</tr>
<tr>
<td>Output</td>
<td>Avstandsmatrise</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>E</mi><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE \lg V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, eller <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mi>lg</mi><mo>⁡</mo><mi>V</mi><mo>+</mo><mi>V</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2 \lg V + VE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ved bruk av fibonacci-haug</td>
</tr>
</tbody>
</table>
<pre><code class="hljs">JOHNSON(G, w)
    compute G<span class="hljs-comment">&#x27;</span>
    <span class="hljs-keyword">if</span> Bellman-Ford(G<span class="hljs-comment">&#x27;, w, s) == False</span>
        print <span class="hljs-string">"the input graph contains a negative-weight cycle"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> vertex v <span class="hljs-keyword">in</span> G<span class="hljs-comment">&#x27;.V</span>
            <span class="hljs-keyword">set</span> h(v) <span class="hljs-keyword">to</span> the value <span class="hljs-keyword">of</span> d(s, v) computed <span class="hljs-keyword">by</span> Bellman-Ford
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> edge (u, v) <span class="hljs-keyword">in</span> G<span class="hljs-comment">&#x27;.E</span>
            w*(u, v) = w(u, v) + h(u) - h(v)
        <span class="hljs-keyword">let</span> D = (d_uv) be a <span class="hljs-built_in">new</span> n*n matrix
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> vertex u <span class="hljs-keyword">in</span> G.V
            run Dijkstra(G, w*, u) <span class="hljs-keyword">to</span> compute d*(u, v) <span class="hljs-keyword">for</span> all v <span class="hljs-keyword">in</span> G.V
            <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> vertex v <span class="hljs-keyword">in</span> G.V
                d_uv = d*(u, v) + h(v) - h(u)
        <span class="hljs-keyword">return</span> D
</code></pre>
<h3>Forelesning 12: Maksimal flyt</h3>
<h4>[L1] Kunne definere flytnett, flyt og maks-flyt-problemet</h4>
<p>Se kompendium s. 138.</p>
<h4>[L2] Kunne håndtere antiparallelle kanter og flere kilder og sluk</h4>
<p>Se kompendium s. 139.</p>
<h4>[L3] Kunne definere restnettet til et flytnett med en gitt flyt</h4>
<p>Se kompendium s. 140.</p>
<h4>[L4] Forstå hvordan man kan oppheve (cancel) flyt</h4>
<p>Se kompendium s. 140.</p>
<h4>[L5] Forstå hva en forøkende sti (augmenting path) er</h4>
<p>Se kompendium s. 141.</p>
<h4>[L6] Forstå hva snitt, snitt-kapasitet og minimalt snitt er</h4>
<p>Se kompendium s. 142.</p>
<h4>[L7] Forstå maks-flyt/min-snitt-teoremet</h4>
<p>Se kompendium s. 143.</p>
<h4>[L8] Forstå Ford-Fulkerson-Method og Ford-Fulkerson</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Ford-Fulkerson</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Implementasjon av Ford-Fulkerson-Method, finner maks flyt</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">s</span></code>: kilde, <code><span class="hljs-attribute">t</span></code>: sluk</td>
</tr>
<tr>
<td>Output</td>
<td>Kantene sine <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>-verdier indikerer maks-flyten</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><msup><mi>f</mi><mo>∗</mo></msup><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E | f^*|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<pre><code class="hljs">FORD-FULKERSON-<span class="hljs-keyword">METHOD</span><span class="hljs-params">(G, s, t)</span>
    <span class="hljs-title function_">initialize</span> <span class="hljs-title function_">flow</span> <span class="hljs-title function_">f</span> <span class="hljs-title function_">to</span> 0
    <span class="hljs-title function_">while</span> <span class="hljs-title function_">there</span> <span class="hljs-title function_">exists</span> <span class="hljs-title function_">an</span> <span class="hljs-title function_">augmenting</span> <span class="hljs-title function_">path</span> <span class="hljs-title function_">p</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">residual</span> <span class="hljs-title function_">network</span> <span class="hljs-title function_">Gf</span>
        <span class="hljs-title function_">augment</span> <span class="hljs-title function_">flow</span> <span class="hljs-title function_">f</span> <span class="hljs-title function_">along</span> <span class="hljs-title function_">p</span>
    <span class="hljs-title function_">return</span> <span class="hljs-title function_">f</span>

<span class="hljs-title function_">FORD</span>-<span class="hljs-title function_">FULKERSON</span><span class="hljs-params">(G, s, t)</span>
    <span class="hljs-title function_">for</span> <span class="hljs-title function_">each</span> <span class="hljs-title function_">edge</span> <span class="hljs-params">(u, v)</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">G</span>.<span class="hljs-title function_">E</span>
        <span class="hljs-params">(u, v)</span>.<span class="hljs-title function_">f</span> = 0
    <span class="hljs-title function_">while</span> <span class="hljs-title function_">there</span> <span class="hljs-title function_">exists</span> <span class="hljs-title function_">a</span> <span class="hljs-title function_">path</span> <span class="hljs-title function_">p</span> <span class="hljs-title function_">from</span> <span class="hljs-title function_">s</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">t</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">residual</span> <span class="hljs-title function_">network</span> <span class="hljs-title function_">Gf</span>
        <span class="hljs-title function_">cf</span><span class="hljs-params">(p)</span> = <span class="hljs-title function_">min</span><span class="hljs-comment">{cf(u, v) : (u, v) is in p}</span>
        <span class="hljs-title function_">for</span> <span class="hljs-title function_">each</span> <span class="hljs-title function_">edge</span> <span class="hljs-params">(u, v)</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">p</span>
            <span class="hljs-title function_">if</span> <span class="hljs-params">(u, v)</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">E</span>
                <span class="hljs-params">(u, v)</span>.<span class="hljs-title function_">f</span> = <span class="hljs-params">(u, v)</span>.<span class="hljs-title function_">f</span> + <span class="hljs-title function_">cf</span><span class="hljs-params">(p)</span>
            <span class="hljs-title function_">else</span> <span class="hljs-params">(u, v)</span>.<span class="hljs-title function_">f</span> = <span class="hljs-params">(u, v)</span>.<span class="hljs-title function_">f</span> - <span class="hljs-title function_">cf</span><span class="hljs-params">(p)</span>
</code></pre>
<h4>[L9] Vite at Ford-Fulkerson med BFS kalles Edmonds-Karp-algoritmen</h4>
<table>
<thead>
<tr>
<th>Attributt</th>
<th>Edmonds-Karp</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beskrivelse</td>
<td>Ford-Fulkerson med BFS, finner maks flyt</td>
</tr>
<tr>
<td>Input</td>
<td><code><span class="hljs-attribute">G</span></code>: en graf, <code><span class="hljs-attribute">s</span></code>: kilde, <code><span class="hljs-attribute">t</span></code>: sluk</td>
</tr>
<tr>
<td>Output</td>
<td>kantene sine <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>-verdier indikerer maks-flyten</td>
</tr>
<tr>
<td>Kjøretid</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><msup><mi>E</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h4>[L10] Forstå hvordan maks-flyt kan finne en maksimum bipartitt matching</h4>
<p>Se kompendium s. 147.</p>
<h4>[L11] Forstå heltallsteoremet (integrality theorem)</h4>
<p>Se kompendium s. 148.</p>
<h3>Forelesning 13: NP-kompletthet</h3>
<h4>[M1] Forstå sammenhengen mellom optimerings- og beslutnings-problemer</h4>
<p>Optimeringsproblemer har gjerne tilhørende beslutningsproblemer og omvendt. For eksempel kan optimeringsproblemet <em>å finne korteste vei</em> knyttes til beslutningsproblemet <em>finnes det en vei med avstand <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>?</em>.</p>
<h4>[M2] Forstå koding (encoding) av en instans</h4>
<p>Se kompendium s. 152.</p>
<h4>[M3] Forstå hvorfor løsningen på det binære ryggsekkproblemet ikke er polynomisk</h4>
<p>Se kompendium s. 93 og 162.</p>
<h4>[M4] Forstå forskjellen på konkrete og abstrakte problemer</h4>
<p>Men hovedpoenget er altså at konkrete problemer er, på sett og vis, konkrete representasjoner av de abstrakte problemene, der instansene er kodet som strenger (f.eks. serier med bits), akkurat som i en datamaskin, mens abstrakte problemer bare er abstrakte, matematiske problemer (relasjoner mellom input/output). Se mer på side 1054-1055.</p>
<h4>[M5] Forstå representasjonen av beslutningsproblemer som formelle språk</h4>
<p>Se kompendium s. 153.</p>
<h4>[M6] Forstå definisjonen av klassene P, NP og co-NP</h4>
<p>NP er beslutningsproblemer der ja-svar kan verifiseres i polynomisk tid. co-NP er beslutninger der nei-svar kan verifiseres i polynomisk tid. P er problemene i NP som kan løses i polynomisk tid.</p>
<h4>[M7] Forstå redusibilitets-relasjonen <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≤</mo><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\leq_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.922078em;vertical-align:-0.286108em;"></span><span class="mrel"><span class="mrel">≤</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></h4>
<p>Dersom vi reduserer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> til <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> skriver vi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mo>≤</mo><mi>p</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A \leq_p B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">≤</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>. Det vil si at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> er minst like vanskelig som <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<h4>[M8] Forstå definisjonen av NP-hardhet og NP-kompletthet</h4>
<p>At et problem er NP-hardt vil si at det er minst like vanskelig som de vanskeligste problemene i NP. Hvis et problem er i NP og er NP-hardt, så er det NP-komplett.</p>
<h4>[M9] Forstå den konvensjonelle hypotesen om forholdet mellom P, NP og NPC</h4>
<p>Se kompendium s. 155.</p>
<h4>[M10] Forstå hvordan NP-kompletthet kan bevises ved én reduksjon</h4>
<p>Dersom vi reduserer et problem som er bevist NP-komplett <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, til et problem <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> i NP, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mo>≤</mo><mi>p</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A \leq_p B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">≤</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, vet vi at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> er minst like vanskelig som <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> og derfor også NP-komplett.</p>
<h4>[M11] Kjenne de NP-komplette problemene CIRCUIT-SAT, SAT, 3-CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP og SUBSET-SUM</h4>
<p>Se kompendium s. 159.</p>
<h4>[M12] Forstå at det binære ryggsekkproblemet er NP-hardt</h4>
<p>Se kompendium s. 93 og 162.</p>
<h4>[M13] Forstå at lengste enkle-vei-problemet er NP-hardt</h4>
<p>Hamiltonvei-problemet kan reduseres til lengste enkle-vei-problemet, derfor er lengste enkle-vei-problemet NP-hardt.</p>
<h4>[M14] Være i stand til å konstruere enkle NP-kompletthetsbevis</h4>
<p>Ved reduksjon fra NP-komplette problemer.</p>


</article>
</body>

</html>
