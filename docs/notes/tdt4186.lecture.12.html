<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Katex -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
  <!-- GitHub Markdown Styles -->
  <link rel="stylesheet" href=
      "https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>
  
  <title>tdt4186.lecture.12.md</title>
  <link rel="icon" type="image/x-icon" href="../null">
  
<!-- Custom Styles -->
<link rel="stylesheet" href="../styles.css">


</head>
<body>
<article class="markdown-body">

<p>↩️ <a href="./index.html">notes</a></p>
<h2>Lecture 12: Uniprocessor scheduling</h2>
<p><a href="tdt4186.lecture.11.html">Previous lecture</a>
<a href="notes/tdt4186.lecture.13.html">Next lecture</a></p>
<p>&lt;iframe
width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/JQuFo8yMkxk&quot;
title=&quot;YouTube video player&quot;
frameborder=&quot;0&quot;
allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
allowfullscreen</p>
<blockquote>
<p>&lt;/iframe&gt;</p>
</blockquote>
<h3>Processes once again…</h3>
<ul>
<li>Processes are (still…) the central abstraction for activities in</li>
</ul>
<p>current operating system</p>
<ul>
<li>illusion of independent sequential control flows as a concept (sequence of CPU and I/O bursts)</li>
<li>in real life, the CPU is multiplexed</li>
<li>Unix systems provide a set of system calls to create and</li>
</ul>
<p>manage processes and to provide communication channels</p>
<ul>
<li>in addition, modern operating systems also support light and featherweight processes</li>
<li>Processes are controlled by the operating system
<ul>
<li>allocation of resources</li>
<li>preemption of resources</li>
</ul>
</li>
</ul>
<h3>Dispatch states</h3>
<p>Depending on the scheduling level, every process is assigned a
logical state representing its dispatch state at a given point in
time:</p>
<ul>
<li>short-term scheduling (µs – ms)*
<ul>
<li>ready, running, blocked</li>
</ul>
</li>
<li>medium-term scheduling (ms – min)*
<ul>
<li>swapped and ready, swapped and blocked</li>
</ul>
</li>
<li>long-term scheduling (min – hours)*
<ul>
<li>created, terminated</li>
</ul>
</li>
</ul>
<p>*Rule of thumb how often a scheduling decision or state change occurs</p>
<h3>Short-term scheduling</h3>
<ul>
<li>ready to be executed by the CPU
<ul>
<li>a process is on the ready (waiting) list for CPU allocation</li>
<li>its list position depends on the scheduling algorithm</li>
</ul>
</li>
<li>running: resource &quot;CPU&quot; has been allocated to the process
<ul>
<li>a process is computing: &quot;CPU burst&quot;</li>
<li>there is only one running process per CPU at any given moment in time</li>
</ul>
</li>
<li>blocked: waiting for an event
<ul>
<li>a process performs input or output: &quot;I/O burst&quot;</li>
<li>it waits for the occurrence of at least one condition</li>
</ul>
</li>
</ul>
<h3>Medium-term scheduling</h3>
<p>A process is completely swapped out</p>
<ul>
<li>the complete contents of its address space are moved to background storage</li>
<li>the main memory it used is released</li>
</ul>
<p>The process has to wait to be swapped in:</p>
<ul>
<li>swapped out ready (READY SUSPEND)
<ul>
<li>CPU allocation ignores this process</li>
<li>the process is on a waiting list for memory allocation</li>
</ul>
</li>
<li>swapped out blocked (BLOCKED SUSPEND)
<ul>
<li>the process waits for an event (it is blocked)</li>
<li>if this event takes place, the process state changes to READY SUSPEND</li>
</ul>
</li>
</ul>
<h3>Long-term scheduling</h3>
<ul>
<li>Processes are created (NEW) and ready to be started: fork(2)
<ul>
<li>a process instance was created and assigned to a program</li>
<li>the allocation of the resource &quot;memory&quot; might still be outstanding (e.g. when paging in parts of the process address space on demand)</li>
</ul>
</li>
<li>Processes are terminated (EXIT) and wait for their removal: exit(2)/wait(2)
<ul>
<li>the process is terminated, its resources are released</li>
<li>the &quot;cleanup&quot; after process termination can be performed by a different process (e.g. in Unix)</li>
</ul>
</li>
</ul>
<h3>State transitions</h3>
<p><img src="../assets/tdt4186.lecture.12.state_transitions.png" alt=""></p>
<h3>Scheduling points</h3>
<ul>
<li>Every transition into the READY state updates the CPU waiting queue
<ul>
<li>a decision about the queueing of its process control blocks is made</li>
<li>the result depends on the CPU allocation strategy of the system</li>
</ul>
</li>
<li>Scheduling and rescheduling takes places…
<ol>
<li>after a process is created</li>
<li>if a process yields control of the CPU</li>
<li>if the event a process is waiting for takes place</li>
<li>when a swapped out process is considered for CPU allocation again</li>
</ol>
</li>
<li>A process can be forced to yield (release) the CPU → preemptive scheduling
<ul>
<li>e.g. using a timer interrupt</li>
</ul>
</li>
</ul>
<h3>First-Come First-Served – FCFS</h3>
<ul>
<li>A simple and fair (?) algorithm: &quot;first come first served&quot;</li>
<li>Queueing criterion is the arrival time of a process</li>
<li>Algorithm is non preempting and assumes cooperating processes</li>
</ul>
<p><img src="../assets/tdt4186.lecture.12.fcfs.png" alt=""></p>
<ul>
<li>Example:</li>
<li>the normalized runtime (Tr / Ts) of C is bad in relation to its service time Ts</li>
</ul>
<h3>Discussion: FCFS – &quot;convoi effect&quot;</h3>
<ul>
<li>This problem affects short running I/O-intensive processes which follow long CPU-intensive processes
<ul>
<li>Processes with long CPU bursts benefit from this</li>
<li>Processes with short CPU bursts are disadvantaged</li>
</ul>
</li>
<li>FCFS minimizes the number of context switches. However, the convoi effect causes a number of problems:
<ul>
<li>large response time</li>
<li>low I/O throughput</li>
</ul>
</li>
<li>If the system runs a mix of CPU- and I/O-intensive processes,</li>
</ul>
<p>FCFS is not a suitable approach</p>
<ul>
<li>it is typically only used in batch processing systems</li>
</ul>
<h3>Round Robin (RR)</h3>
<ul>
<li>Reduces the disadvantage of processes with short CPU bursts: &quot;everyone for themselves!&quot;
<ul>
<li>the available processor time is split into time slices</li>
</ul>
</li>
<li>When a time slice is used up, a process switch can occur
<ul>
<li>the interrupted process is moved to the end of the ready list</li>
<li>the next process is selected from ready list according to FCFS</li>
</ul>
</li>
<li>Basis for protecting access to the CPU: a timer enforces an interrupt at the end of each time slice</li>
<li>The efficiency of this approach depends essentially on the chosen length of the time slice
<ul>
<li>too long ➛ round robin degenerates to FCFS</li>
<li>too short ➛ very high overhead for process switches</li>
</ul>
</li>
<li>Rule of thumb: time slices should be &quot;a bit longer&quot; than the duration of a &quot;typical interaction&quot;</li>
</ul>
<h3>Discussion: RR – performance problems</h3>
<ul>
<li>I/O-intensive processes terminate their CPU burst before their time slice is used up
<ul>
<li>they block and are added back to the ready list when their I/O burst is finished</li>
</ul>
</li>
<li>CPU-intensive processes, however, use their time slice completely
<ul>
<li>they are then preempted and immediately added to the end of the ready list</li>
</ul>
</li>
<li>The amount of CPU time for processes is thus distributed</li>
</ul>
<p>inequally ➛ CPU-intensive processes get a larger share</p>
<ul>
<li>I/O-intensive processes are not served as well, thus the utilization of I/O devices is low</li>
<li>the variance of the response time of I/O-intensive processes increases</li>
</ul>
<h3>Virtual Round Robin (VRR)</h3>
<ul>
<li>Avoids the unequal distribution of CPU times with RR
<ul>
<li>processes are added to a preferred list when their I/O burst ends</li>
<li>this list is considered before the ready list</li>
</ul>
</li>
<li>Virtual Round Robin uses time slices of different lengths
<ul>
<li>processes on the preferred list are only allocated a partial time slice</li>
<li>they can use the remaining run time they did not use in their previous time slice</li>
<li>if their CPU burst last longer, they are moved to the ready list</li>
</ul>
</li>
<li>Scheduling in VRR involves a bit more overhead compared to RR</li>
</ul>
<h3>Shortest process next (SPN)</h3>
<ul>
<li>Reduces the disadvantage of short CPU bursts with FCFS: &quot;let the shortest come first…&quot;
<ul>
<li>this requires knowledge about the process run times</li>
<li>no preemption</li>
</ul>
</li>
<li>The main problem here is the prediction of run times
<ul>
<li>batch processing: the programmer annotates the required time limit</li>
<li>interactive procession: time limit estimated based on previous CPU burst lengths of the process</li>
</ul>
</li>
<li>Response times are reduced significantly and the overall system performance is increased
<ul>
<li>However: danger of starvation of CPU-intensive processes</li>
</ul>
</li>
</ul>
<h3>Discussion: SPN – weighting bursts</h3>
<ul>
<li>CPU bursts further in the past should be weighted less:</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><mo>⋅</mo><msub><mi>T</mi><mi>n</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_{n + 1} = \alpha \cdot T_n + (1 - \alpha) \cdot S_n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>values of the constant weighting factor α: 0 &lt; α &lt; 1</li>
<li>it represents the relative weighting of</li>
</ul>
<p>single CPU bursts in the time line of
the process</p>
<ul>
<li>Recursive solving leads us to...</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mi>i</mi></msup><mtext> </mtext><msub><mi>T</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup><mo>⋅</mo><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_{n + 1} = \alpha \cdot \sum_{i = 0}^{n - 1} (1 - \alpha)^i \, T_{n - i} + (1 - \alpha)^n \cdot S_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1246639999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>This statistical approach is also called exponential smoothing.</p>
<h3>Shortest Remaining Time First (SRTF)</h3>
<ul>
<li>Extends SPN with preemption
<ul>
<li>thus appropriate for interactive operation</li>
<li>results in improved runtimes</li>
</ul>
</li>
<li>The running process is preempted if Texp &lt; Trest
<ul>
<li>Texp is the expected CPU burst length of an arriving process</li>
<li>Trest is the remaining CPU burst length of the running process</li>
</ul>
</li>
<li>Difference to RR: SRTF is not based on timer interrupts, but nevertheless preemptive
<ul>
<li>We have to estimate burst lengths instead</li>
</ul>
</li>
<li>Like SPN, processes can also starve using SRTF</li>
</ul>
<h3>Highest Response Ratio Next – HRRN</h3>
<ul>
<li>Avoids the possible starvation of CPU-intensive processes that can occur with SRTF
<ul>
<li>HRRN considers the aging of processes – their waiting time</li>
</ul>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mrow><mi>w</mi><mo>+</mo><mi>s</mi></mrow><mi>s</mi></mfrac></mrow><annotation encoding="application/x-tex">R = \frac{w + s}{s}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9463300000000001em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>w is the &quot;waiting time&quot; the process has accumulated so far</li>
<li>s is the &quot;expected service time&quot;</li>
<li>HRRN always selects the process with the highest value of R
<ul>
<li>Again, this is based on an estimation of the service time</li>
</ul>
</li>
</ul>
<h3>Feedback (FB)</h3>
<ul>
<li>Short processes obtain an advantage without having to estimate the relative lengths of processes
<ul>
<li>Basis is the penalization of long running processes</li>
<li>Processes are preempted</li>
</ul>
</li>
<li>Multiple ready lists used according to number of priority levels
<ul>
<li>when a process arrives for the first time, it has highest priority</li>
<li>when its time slice is used up, it is moved to the next lower priority level</li>
<li>the lowest level works according to RR</li>
</ul>
</li>
<li>Short processes finish in a relatively short amount of time, but long processes can starve
<ul>
<li>It is possible to consider the waiting time to move a process back to a higher priority level (anti-aging)</li>
</ul>
</li>
</ul>
<p><img src="../assets/tdt4186.lecture.12.feedback_scheduling_model.png" alt=""></p>
<h3>Discussion: Priorities</h3>
<ul>
<li>Process priorities significantly influence scheduling decisions</li>
<li>Static priorities are defined when a process is created
<ul>
<li>their value cannot be changed during the execution of the process</li>
<li>this enforces a deterministic ordering of processes</li>
</ul>
</li>
<li>Dynamic priorities are updated while a process is running
<ul>
<li>the operating system usually updates the priorities, but also the user can be allowed to influence priorities</li>
<li>SPN, SRTF, HRRN and FB are special cases of this approach</li>
</ul>
</li>
</ul>
<h3>Combination – Multi-level scheduling</h3>
<ul>
<li>Multiple scheduling strategies can be combined (i.e., used</li>
</ul>
<p>&quot;simultaneously&quot;), e.g. support of</p>
<ul>
<li>interactive and background processing or</li>
<li>realtime and non-realtime processing
<ul>
<li>interactive / real-time critical processes are preferred</li>
</ul>
</li>
<li>The implementation typically uses multiple ready lists
<ul>
<li>every ready lists has its own scheduling strategy</li>
<li>the lists are typically processed using priority, FCFS or RR</li>
<li>overall, a very complex approach!</li>
</ul>
</li>
<li>FB can be seen as a special case of this approach</li>
</ul>
<p><img src="../assets/tdt4186.lecture.12.multi_level_scheduling.png" alt=""></p>
<h3>Objectives for evaluation</h3>
<ul>
<li>User oriented:
<ul>
<li>Run time – time between start and termination of a process including the waiting time(s) → batch processing</li>
<li>Response time – time between user input and program response → interactive systems</li>
<li>Tardiness – for the interaction with external physical processes, deadlines have to be adhered to → real-time systems</li>
<li>Predictability – processes are always processed identically independent of the load → hard real-time systems</li>
</ul>
</li>
<li>System oriented:
<ul>
<li>Throughput – finish as many processes as possible per time unit</li>
<li>CPU load – keep the CPU busy at all times
<ul>
<li>avoid overhead (scheduling decisions, context switches)</li>
</ul>
</li>
<li>Fairness – no process should be disadavantaged (e.g. by starvation)</li>
<li>Load balancing – I/O devices should also be utilized uniformly</li>
</ul>
</li>
</ul>
<h3>Quantative comparison</h3>
<p><img src="../assets/tdt4186.lecture.12.quantative_comparison.png" alt=""></p>
<h3>Qualitative comparison</h3>
<p><img src="../assets/tdt4186.lecture.12.qualitative_comparison.png" alt=""></p>
<h3>Scheduling in Unix</h3>
<ul>
<li>Two step preemptive approach
<ul>
<li>objective: reduce response times</li>
</ul>
</li>
<li>No long term scheduling</li>
<li>high-level: mid term, using swapping</li>
<li>low-level: short term preemptive, MLFB, dynamic process priorities</li>
</ul>
<pre><code class="hljs"><span class="hljs-attr">prio</span> = cpu_usage + p_nice + base
</code></pre>
<ul>
<li>Once a second:
<ul>
<li>every &quot;tick&quot; (1/10 s) reduces the &quot;usage entitlement&quot; for the CPU by increasing cpu_usage for the running process</li>
<li>high prio value = low priority!</li>
</ul>
</li>
<li>The amount of cpu_usage over the time is reduced (smoothed)
<ul>
<li>the smoothing function is different in various versions of Uni</li>
</ul>
</li>
</ul>
<h3>UNIX – 4.3 BSD (1)</h3>
<ul>
<li>The user priority is determined at every fourth tick (40ms):</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>u</mi><mi>s</mi><mi>r</mi><mi>p</mi><mi>r</mi><mi>i</mi></mrow></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>P</mi><mi>U</mi><mi>S</mi><mi>E</mi><mi>R</mi><mo>+</mo><mfrac><msub><mi>P</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mn>4</mn></mfrac><mo>+</mo><mn>2</mn><mo>⋅</mo><msub><mi>P</mi><mrow><mi>n</mi><mi>i</mi><mi>c</mi><mi>e</mi></mrow></msub><mo separator="true">,</mo><mn>127</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_{usrpri} = \min(PUSER + \frac{P_{cpu}}{4} + 2 \cdot P_{nice}, 127)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>Pcpu is incremented (by 1) with every tick and is smoothed once</li>
</ul>
<p>a second:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mtext>  </mtext><mo>⟸</mo><mtext>  </mtext><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi></mrow><mrow><mn>2</mn><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>⋅</mo><msub><mi>P</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mi>n</mi><mi>i</mi><mi>c</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{cpu} \impliedby \frac{2 \cdot load}{2 \cdot load + 1} \cdot P_{cpu} + P_{nice}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>Smooting for processes that are woken up and were blocked for</li>
</ul>
<p>more than 1 second:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mtext>  </mtext><mo>⟸</mo><mtext>  </mtext><msup><mrow><mo fence="true">(</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi></mrow><mrow><mn>2</mn><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><msub><mi>P</mi><mrow><mi>s</mi><mi>l</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></msub></msup><mo>⋅</mo><msub><mi>P</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P_{cpu} \impliedby \left( \frac{2 \cdot load}{2 \cdot load + 1} \right)^{P_{slptime}} \cdot P_{cpu}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟸</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.631261em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.681231em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h3>UNIX – 4.3 BSD (2)</h3>
<ul>
<li>Smoothing (using a decay filter):</li>
</ul>
<p>for an assumed average load of 1: Pcpu := 0.66 · Pcpu + Pnice</p>
<ul>
<li>In addition, we assume that a process collects Ti ticks in the time</li>
</ul>
<p>interval i and Pnice = 0</p>
<pre><code class="hljs"><span class="hljs-attribute">Pcpu1</span> = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T0
<span class="hljs-attribute">Pcpu2</span> = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> (T1 + <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T0 ) = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T1 + <span class="hljs-number">0</span>.<span class="hljs-number">44</span> T0
<span class="hljs-attribute">Pcpu3</span> = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T2 + <span class="hljs-number">0</span>.<span class="hljs-number">44</span> T1 + <span class="hljs-number">0</span>.<span class="hljs-number">30</span> T0
<span class="hljs-attribute">Pcpu4</span> = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T3 + … + <span class="hljs-number">0</span>.<span class="hljs-number">20</span> T0
<span class="hljs-attribute">Pcpu5</span> = <span class="hljs-number">0</span>.<span class="hljs-number">66</span> T4 + … + <span class="hljs-number">0</span>.<span class="hljs-number">13</span> T0
</code></pre>
<ul>
<li>After 5 seconds, only 13% of the &quot;old&quot; load are considered</li>
</ul>
<h3>Windows NT – Priority classes</h3>
<ul>
<li>Preemptive, priority- and time slice-based thread scheduling
<ul>
<li>preemption also occurs for threads executing in the kernel → different to Unix</li>
<li>RR for processes of the same priority: 0 reserved, 1–15 variable, 16-31 real-time</li>
</ul>
</li>
<li>The thread type (fore-/background thread) determines the time quantum available to the thread → quantum stretching
<ul>
<li>quantum (between 6 and 36) is reduced by 3 or 1 with every tick (10 or 15 ms), if the thread changes to the waiting state</li>
<li>the length of a time slice varies with the process: 20–180 ms
<ul>
<li>foreground/background, server or desktop configuration</li>
</ul>
</li>
</ul>
</li>
<li>In addition, NT has variable priorities:
<ul>
<li>process_priority_class + relative_thread_priority + boost</li>
</ul>
</li>
</ul>
<h3>NT – Adaptive priorities</h3>
<ul>
<li>Thread priorities are dynamically increased when certain conditions are given: dynamic boost
<ul>
<li>Completion of input/output (disk): +1</li>
<li>Mouse movement, keyboard input: +6</li>
<li>Deblocking, release of resources (semaphore, event, mutex) +1</li>
<li>Other events (network, pipe, …) +2</li>
<li>Event in foreground process +2</li>
</ul>
</li>
<li>Dynamic boosts are decreased again (&quot;used up&quot;) with every tick</li>
<li>Guarantee of progress
<ul>
<li>avoids the starvation of threads</li>
<li>up to 10 &quot;disadvantaged&quot; threads are allocated priority 15 for two time slices every 3–4 seconds</li>
</ul>
</li>
</ul>
<h3>Conclusions</h3>
<ul>
<li>Operating systems take CPU scheduling decisions on three different levels:
<ul>
<li>Long term scheduling: admission of processes to the system</li>
<li>Medium term scheduling: swapping of processes</li>
<li>Short term scheduling: short-term CPU allocation</li>
</ul>
</li>
<li>All algorithms discussed in this lecture are considered short term scheduling approaches:
<ul>
<li>there are different user- and system oriented criteria to assess the properties of a CPU scheduling algorithm</li>
<li>the selection of an approach is difficult and can have unexpected negative effects</li>
<li>the &quot;best&quot; approach can only be found by an analysis of typical application profiles and all given constraints</li>
</ul>
</li>
</ul>


</article>
</body>
</html>
